<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>tedata.utils API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tedata.utils</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tedata.utils.check_browser_installed"><code class="name flex">
<span>def <span class="ident">check_browser_installed</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_browser_installed():
    &#34;&#34;&#34;Check if browsers are installed using Selenium&#39;s service checks&#34;&#34;&#34;
    firefox_available = False
    chrome_available = False
    
    try:
        firefox_service = FirefoxService()
        firefox_service.is_connectable()  # This checks if Firefox is available
        firefox_available = True
    except WebDriverException:
        pass

    try:
        chrome_service = ChromeService()
        chrome_service.is_connectable()  # This checks if Chrome is available
        chrome_available = True
    except WebDriverException:
        pass

    if not (firefox_available or chrome_available):
        warnings.warn(
            &#34;Neither Firefox nor Chrome browser found. Please install one of them to use this package.&#34;
            &#34;Firefox: https://www.mozilla.org/en-US/firefox/new/&#34;
            &#34;Google Chrome: https://www.google.com/chrome/ &#34;,
            RuntimeWarning
        )
    
    return firefox_available, chrome_available</code></pre>
</details>
<div class="desc"><p>Check if browsers are installed using Selenium's service checks</p></div>
</dd>
<dt id="tedata.utils.check_element_exists_bs4"><code class="name flex">
<span>def <span class="ident">check_element_exists_bs4</span></span>(<span>soup, selector)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_element_exists_bs4(soup, selector):
    try:
        element = soup.select_one(selector)
        return element.text if element else None
    except:
        return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tedata.utils.click_button"><code class="name flex">
<span>def <span class="ident">click_button</span></span>(<span>scraper_object: <a title="tedata.scraper.TE_Scraper" href="scraper.html#tedata.scraper.TE_Scraper">TE_Scraper</a> | <a title="tedata.utils.TooltipScraper" href="#tedata.utils.TooltipScraper">TooltipScraper</a>,<br>selector: str = '#dateSpansDiv',<br>selector_type='css selector')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_button(scraper_object: Union[scraper.TE_Scraper, TooltipScraper], 
                 selector: str = &#34;#dateSpansDiv&#34;, 
                 selector_type=By.CSS_SELECTOR):
    
    &#34;&#34;&#34;Click button and wait for response...&#34;&#34;&#34;

    try:
        # Wait for element to be clickable
        button =  WebDriverWait(scraper_object.driver, timeout=10).until(
            EC.element_to_be_clickable((selector_type, selector))
        )
        # Scroll element into view
        #self.driver.execute_script(&#34;arguments[0].scrollIntoView(true);&#34;, button)
        time.sleep(0.25)  # Brief pause after scroll
        button.click()
        #logger.info(&#34;Button clicked successfully, waiting 1s for response...&#34;)
        logger.info(f&#34;Button clicked successfully: {selector} on object {scraper_object}&#34;)
        time.sleep(0.75)
        return True

    except Exception as e:
        logger.info(f&#34;Error clicking button: {str(e)} on object {scraper_object}&#34;)
        return False</code></pre>
</details>
<div class="desc"><p>Click button and wait for response&hellip;</p></div>
</dd>
<dt id="tedata.utils.convert_metric_prefix"><code class="name flex">
<span>def <span class="ident">convert_metric_prefix</span></span>(<span>value_str: str) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_metric_prefix(value_str: str) -&gt; float:
    &#34;&#34;&#34;Convert string with metric prefix to float
    e.g., &#39;1.3K&#39; -&gt; 1300, &#39;2.6M&#39; -&gt; 2600000
    &#34;&#34;&#34;
    # Dictionary of metric prefixes and their multipliers
    metric_prefixes = {
        &#39;K&#39;: 1000,
        &#39;M&#39;: 1000000, 
        &#39;B&#39;: 1000000000,
        &#39;G&#39;: 1000000000,
        &#39;T&#39;: 1000000000000}
    
    # Clean and standardize input
    value_str = value_str.strip().upper()
    
    try:
        # Match number and prefix
        match = re.match(r&#39;^(-?\d*\.?\d+)([KMGBT])?$&#39;, value_str)
        if match:
            number, prefix = match.groups()
            number = float(number)
            # Multiply by prefix value if present
            if prefix and prefix in metric_prefixes:
                number *= metric_prefixes[prefix]
            return number
        return float(value_str)  # No prefix case
    except:
        print(f&#34;Error converting value: {value_str}&#34;)
        return value_str  # Return original if conversion fails</code></pre>
</details>
<div class="desc"><p>Convert string with metric prefix to float
e.g., '1.3K' -&gt; 1300, '2.6M' -&gt; 2600000</p></div>
</dd>
<dt id="tedata.utils.export_html"><code class="name flex">
<span>def <span class="ident">export_html</span></span>(<span>html: str,<br>save_path: str = '/Users/jamesbishop/Documents/Python/Scraping/tedata/src/tedata/last_soup.html')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_html(html: str, save_path: str = wd+fdel+&#39;last_soup.html&#39;):
    with open(save_path, &#39;w&#39;) as wp:
        wp.write(html)
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tedata.utils.find_zero_crossing"><code class="name flex">
<span>def <span class="ident">find_zero_crossing</span></span>(<span>series)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_zero_crossing(series):
    &#34;&#34;&#34;Find the x-intercept (value where series crosses zero) using linear interpolation&#34;&#34;&#34;
    if not ((series.min() &lt; 0) and (series.max() &gt; 0)):
        return None
        
    # Find where values change sign
    for i in range(len(series)-1):
        if (series.iloc[i] &lt;= 0 and series.iloc[i+1] &gt; 0) or \
           (series.iloc[i] &gt;= 0 and series.iloc[i+1] &lt; 0):
            # Get x values (index values)
            x1, x2 = series.index[i], series.index[i+1]
            # Get y values
            y1, y2 = series.iloc[i], series.iloc[i+1]
            # Linear interpolation to find x-intercept
            zero_x = x1 + (0 - y1)*(x2 - x1)/(y2 - y1)
            return zero_x
            
    return None</code></pre>
</details>
<div class="desc"><p>Find the x-intercept (value where series crosses zero) using linear interpolation</p></div>
</dd>
<dt id="tedata.utils.get_chart_datespans"><code class="name flex">
<span>def <span class="ident">get_chart_datespans</span></span>(<span>scraper_object: <a title="tedata.scraper.TE_Scraper" href="scraper.html#tedata.scraper.TE_Scraper">TE_Scraper</a> | <a title="tedata.utils.TooltipScraper" href="#tedata.utils.TooltipScraper">TooltipScraper</a>,<br>selector: str = '#dateSpansDiv')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chart_datespans(scraper_object: Union[scraper.TE_Scraper, TooltipScraper], selector: str = &#34;#dateSpansDiv&#34;):
    &#34;&#34;&#34;Get the date spans from the Trading Economics chart currently displayed in the scraper object. The scraper object can be a TE_Scraperfrom the scraper module
    or TooltipScraper object from the utils module.
    
    ** Parameters:**
    - scraper_object (TE_Scraper or TooltipScraper): The scraper object with the chart to scrape.
    - selector (str): The CSS selector to find the date spans element. Default is &#39;#dateSpansDiv&#39;.
    
    ** Returns:**
    - date_spans (dict): A dictionary with date span names as keys and CSS selectors for the button to select that span as values.
    &#34;&#34;&#34;
    if not isinstance(scraper_object, TooltipScraper) or not isinstance(scraper_object, scraper.TE_Scraper):
        print(&#34;get_chart_datespans function: Invalid scraper object supplies as first arg, must be a scraper.TE_Scraper or utils.TooltipScraper object.&#34;)
        return None
    try:
        buts = scraper_object.page_soup.select_one(selector)
        datebut = buts[0] if isinstance(buts, list) else buts
        scraper_object.date_spans = {child.text: f&#34;a.{child[&#39;class&#39;][0] if isinstance(child[&#39;class&#39;], list) else child[&#39;class&#39;]}:nth-child({i+1})&#34; for i, child in enumerate(datebut.children)}
        return scraper_object.date_spans
    except Exception as e:
        print(f&#34;get_chart_datespans function: Error finding date spans, error: {str(e)}&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>Get the date spans from the Trading Economics chart currently displayed in the scraper object. The scraper object can be a TE_Scraperfrom the scraper module
or TooltipScraper object from the utils module.</p>
<p>** Parameters:**
- scraper_object (TE_Scraper or TooltipScraper): The scraper object with the chart to scrape.
- selector (str): The CSS selector to find the date spans element. Default is '#dateSpansDiv'.</p>
<p>** Returns:**
- date_spans (dict): A dictionary with date span names as keys and CSS selectors for the button to select that span as values.</p></div>
</dd>
<dt id="tedata.utils.get_date_frequency"><code class="name flex">
<span>def <span class="ident">get_date_frequency</span></span>(<span>date_series: pandas.core.series.Series)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_date_frequency(date_series: pd.Series):
    &#34;&#34;&#34;Get the frequency of a date series, for weekly returns day-specific frequency (e.g. W-SUN)&#34;&#34;&#34;
    if date_series.is_monotonic_increasing or date_series.is_monotonic_decreasing:
        diff = date_series.diff().dropna().mean()
        freq = pd.infer_freq(date_series)
        
        if freq is None:
            freq = map_frequency(diff)
        # If weekly frequency, determine the day
        if freq == &#39;W&#39;:
            day_map = {0: &#39;MON&#39;, 1: &#39;TUE&#39;, 2: &#39;WED&#39;, 3: &#39;THU&#39;, 
                        4: &#39;FRI&#39;, 5: &#39;SAT&#39;, 6: &#39;SUN&#39;}
            weekday = date_series.iloc[0].dayofweek
            return f&#39;W-{day_map[weekday]}&#39;
        else:
            return freq
    else:
        return None</code></pre>
</details>
<div class="desc"><p>Get the frequency of a date series, for weekly returns day-specific frequency (e.g. W-SUN)</p></div>
</dd>
<dt id="tedata.utils.invert_series"><code class="name flex">
<span>def <span class="ident">invert_series</span></span>(<span>series: pandas.core.series.Series, max_val: float = None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def invert_series(series: pd.Series, max_val: float = None):
    &#34;&#34;&#34;
    Invert a pandas Series.

    Parameters:
    series (pd.Series): The pandas Series to invert.

    Returns:
    pd.Series: The inverted pandas Series.
    &#34;&#34;&#34;
    if max_val is None:
        max_val = series.max()
        print(f&#34;Max value: {max_val}, subtracting series from this value.&#34;)
    return (max_val - series) #+ series.min()</code></pre>
</details>
<div class="desc"><p>Invert a pandas Series.</p>
<p>Parameters:
series (pd.Series): The pandas Series to invert.</p>
<p>Returns:
pd.Series: The inverted pandas Series.</p></div>
</dd>
<dt id="tedata.utils.map_frequency"><code class="name flex">
<span>def <span class="ident">map_frequency</span></span>(<span>diff)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_frequency(diff):
    &#34;&#34;&#34;Map timedelta to frequency string&#34;&#34;&#34;
    days = diff.days
    if days &gt; 0 and days &lt;= 3:
        return &#34;D&#34;
    elif days &gt; 3 and days &lt;= 14:
        return &#34;W&#34;
    elif days &gt; 14 and days &lt;= 60:
        return &#34;MS&#34;
    elif days &gt; 60 and days &lt;= 120:
        return &#34;QS&#34;
    elif days &gt; 120 and days &lt;= 420:
        return &#34;AS&#34;
    else:
        return &#34;Multi-year&#34;</code></pre>
</details>
<div class="desc"><p>Map timedelta to frequency string</p></div>
</dd>
<dt id="tedata.utils.normalize_series"><code class="name flex">
<span>def <span class="ident">normalize_series</span></span>(<span>series, new_min, new_max)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_series(series, new_min, new_max):
    &#34;&#34;&#34;
    Normalize a pandas Series to a given range [new_min, new_max].

    Parameters:
    series (pd.Series): The pandas Series to normalize.
    new_min (float): The minimum value of the new range.
    new_max (float): The maximum value of the new range.

    Returns:
    pd.Series: The normalized pandas Series.
    &#34;&#34;&#34;
    series_min = series.min()
    series_max = series.max()
    normalized_series = (series - series_min) / (series_max - series_min) * (new_max - new_min) + new_min
    return normalized_series</code></pre>
</details>
<div class="desc"><p>Normalize a pandas Series to a given range [new_min, new_max].</p>
<p>Parameters:
series (pd.Series): The pandas Series to normalize.
new_min (float): The minimum value of the new range.
new_max (float): The maximum value of the new range.</p>
<p>Returns:
pd.Series: The normalized pandas Series.</p></div>
</dd>
<dt id="tedata.utils.ready_datestr"><code class="name flex">
<span>def <span class="ident">ready_datestr</span></span>(<span>date_str: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ready_datestr(date_str: str):
    &#34;&#34;&#34;Replace substrings in datestr using a dictionary to get the string ready
    for parsing to datetime. Using QS frequency convention for quarters.&#34;&#34;&#34;
    
    quarters = {&#34;Q1&#34;: &#34;January&#34;,
                &#34;Q2&#34;: &#34;April&#34;,
                &#34;Q3&#34;: &#34;July&#34;,
                &#34;Q4&#34;: &#34;October&#34;}

    for key, value in quarters.items():
        date_str = date_str.replace(key, value)
    return date_str</code></pre>
</details>
<div class="desc"><p>Replace substrings in datestr using a dictionary to get the string ready
for parsing to datetime. Using QS frequency convention for quarters.</p></div>
</dd>
<dt id="tedata.utils.round_to_freq"><code class="name flex">
<span>def <span class="ident">round_to_freq</span></span>(<span>dates: pandas.core.indexes.datetimes.DatetimeIndex, freq: str) ‑> pandas.core.indexes.datetimes.DatetimeIndex</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_to_freq(dates: pd.DatetimeIndex, freq: str) -&gt; pd.DatetimeIndex:
    &#34;&#34;&#34;Round dates to nearest frequency start.
    
    Args:
        dates: DatetimeIndex to round
        freq: Frequency string (e.g. &#39;MS&#39;, &#39;QS&#39;, &#39;AS&#39;, &#39;W-SUN&#39;)
    
    Returns:
        DatetimeIndex: Dates rounded to nearest frequency start
    &#34;&#34;&#34;
    # Map common frequencies to period frequencies
    freq_map = {
        &#39;MS&#39;: &#39;M&#39;,  # Month Start -&gt; Month
        &#39;QS&#39;: &#39;Q&#39;,  # Quarter Start -&gt; Quarter
        &#39;AS&#39;: &#39;A&#39;,  # Year Start -&gt; Year
        &#39;W-SUN&#39;: &#39;W&#39;  # Week Start (Sunday) -&gt; Week
    }
    
    # Convert frequency if needed
    period_freq = freq[0] #Try just taking the first letter of the frequency string.
    #freq_map.get(freq, freq)
    
    def _round_single_date(dt):
        # Get current and next period starts
        current_period = pd.Timestamp(dt).normalize().to_period(period_freq).to_timestamp()
        next_period = (pd.Timestamp(dt).normalize().to_period(period_freq) + 1).to_timestamp()
        
        # Calculate distances
        dist_to_current = abs((dt - current_period).total_seconds())
        dist_to_next = abs((dt - next_period).total_seconds())
        
        # Return closest period start
        return next_period if dist_to_next &lt; dist_to_current else current_period

    rounded_dates = [_round_single_date(dt) for dt in dates]
    return pd.DatetimeIndex(rounded_dates)</code></pre>
</details>
<div class="desc"><p>Round dates to nearest frequency start.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dates</code></strong></dt>
<dd>DatetimeIndex to round</dd>
<dt><strong><code>freq</code></strong></dt>
<dd>Frequency string (e.g. 'MS', 'QS', 'AS', 'W-SUN')</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DatetimeIndex</code></dt>
<dd>Dates rounded to nearest frequency start</dd>
</dl></div>
</dd>
<dt id="tedata.utils.round_to_month_start"><code class="name flex">
<span>def <span class="ident">round_to_month_start</span></span>(<span>dates: pandas.core.indexes.datetimes.DatetimeIndex)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def round_to_month_start(dates: pd.DatetimeIndex):
    &#34;&#34;&#34;Round dates to nearest month start.
    
    Args:
        dates: DatetimeIndex of dates to round
        
    Returns:
        DatetimeIndex: Dates rounded to nearest month start
    &#34;&#34;&#34;
    def _round_single_date(dt):
        if dt.day &gt; 15:
            # Roll forward to next month start
            if dt.month == 12:
                return pd.Timestamp(f&#34;{dt.year + 1}-01-01&#34;)
            else:
                return pd.Timestamp(f&#34;{dt.year}-{dt.month + 1:02d}-01&#34;)
        else:
            # Roll back to current month start
            return pd.Timestamp(f&#34;{dt.year}-{dt.month:02d}-01&#34;)

    rounded_dates = [_round_single_date(dt) for dt in dates]
    return pd.DatetimeIndex(rounded_dates)</code></pre>
</details>
<div class="desc"><p>Round dates to nearest month start.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dates</code></strong></dt>
<dd>DatetimeIndex of dates to round</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>DatetimeIndex</code></dt>
<dd>Dates rounded to nearest month start</dd>
</dl></div>
</dd>
<dt id="tedata.utils.show_position_marker"><code class="name flex">
<span>def <span class="ident">show_position_marker</span></span>(<span>scraper_object: <a title="tedata.scraper.TE_Scraper" href="scraper.html#tedata.scraper.TE_Scraper">TE_Scraper</a> | <a title="tedata.utils.TooltipScraper" href="#tedata.utils.TooltipScraper">TooltipScraper</a>,<br>x: int,<br>y: int,<br>duration_ms: int = 5000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_position_marker(scraper_object: Union[scraper.TE_Scraper, TooltipScraper], 
                         x: int, y: int, duration_ms: int = 5000):
    &#34;&#34;&#34;Add visual marker at specified coordinates&#34;&#34;&#34;

    if not isinstance(scraper_object, TooltipScraper) or not isinstance(scraper_object, scraper.TE_Scraper):
        print(&#34;get_chart_datespans function: Invalid scraper object supplies as first arg, must be a scraper.TE_Scraper or utils.TooltipScraper object.&#34;)
        return None
    
    js_code = &#34;&#34;&#34;
        // Create dot element
        const dot = document.createElement(&#39;div&#39;);
        dot.style.cssText = `
            position: absolute;
            left: ${arguments[0]}px;
            top: ${arguments[1]}px;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            z-index: 9999;
            pointer-events: none;
        `;
        document.body.appendChild(dot);
        
        // Remove after duration
        setTimeout(() =&gt; dot.remove(), arguments[2]);
    &#34;&#34;&#34;
    scraper_object.driver.execute_script(js_code, x, y, duration_ms)</code></pre>
</details>
<div class="desc"><p>Add visual marker at specified coordinates</p></div>
</dd>
<dt id="tedata.utils.split_numeric"><code class="name flex">
<span>def <span class="ident">split_numeric</span></span>(<span>input_string: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_numeric(input_string: str):
    # Match integers or decimal numbers
    # Match numbers including metric suffixes
    if not isinstance(input_string, str):
        #print(&#34;split_numeric function: Input is not a string, returning input.&#34;)
        return input_string
    else:
        number_pattern = r&#39;-?\d*\.?\d+[KMGBT]?&#39;
        
        # Find the numeric part
        match = re.search(number_pattern, input_string)
        
        if match:
            numeric_part = match.group()
            # Replace the numeric part with empty string to get remainder
            non_numeric = re.sub(number_pattern, &#39;&#39;, input_string)
            return numeric_part, non_numeric.strip()
        else:   
            return input_string</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tedata.utils.TooltipScraper"><code class="flex name class">
<span>class <span class="ident">TooltipScraper</span></span>
<span>(</span><span>parent_instance=None, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TooltipScraper(scraper.TE_Scraper):
    &#34;&#34;&#34; Extended version of TE_Scraper with additional functionality to scrape tooltip data from a chart element using Selenium.
    Can be initilized using a TE_Scraper object or a new URL. If using a new URL, a new webdriver will be created. If using an existing
    TE_Scraper object, the webdriver from that object will be used and all attributes will be copied over.
    This can get x, y data from the tooltip box displayed by a site such as Trading Economics when the cursor
    is moved over a chart. It can move the cursor to specific points on the chart and extract tooltip text.
    It extracts date and value data from the tooltip text.
    Initialize the scraper with a URL and chart coordinates

    **init Parameters:**
    - parent_instance (scraper.TE_Scraper): A parent scraper object to copy attributes from. This is the most efficient way to initialize.
    - **kwargs: Keyword arguments to pass to the parent class, these are TE_Scraper init key word arguments.
    Generally you would not supply keyword arguments if you are using a parent_instance for initilization. The kwargs apply to creation
    of a new TE_Scraper object. See TE_scraper class for details on initialization of a fresh instance.

    &#34;&#34;&#34;
    
    def __init__(self, parent_instance=None, **kwargs):
        &#34;&#34;&#34; Initialize the TooltipScraper object&#34;&#34;&#34;
        if parent_instance:  # Copy attributes from parent instance
            self.__dict__.update(parent_instance.__dict__)
            self.observers.append(self)
        else:
            super().__init__(**kwargs)

    def get_chart_dims(self):
        &#34;&#34;&#34;Get dimensions of chart and plotting area&#34;&#34;&#34;
        try:
            # Ensure full_chart is WebElement
            self.chart_element = self.driver.find_element(By.CSS_SELECTOR, &#34;#chart&#34;)
                
            # Get overall chart dimensions
            self.chart_rect = {k: round(float(v), 1) for k, v in self.chart_element.rect.items()}
            
            # Get plot area dimensions
            self.plot_background = self.driver.find_element(By.CSS_SELECTOR, &#39;.highcharts-plot-background&#39;)
            self.axes_rect = {k: round(float(v), 1) for k, v in self.plot_background.rect.items()}
            self.chart_x = self.axes_rect[&#34;width&#34;]
            self.chart_y = self.axes_rect[&#34;height&#34;]
            return True
        
        except Exception as e:
            print(f&#34;Failed to get chart dimensions: {e}&#34;)
            logger.error(f&#34;Failed to get chart dimensions: {e}&#34;)
            return False
    
    def move_cursor(self, x: int = 0, y: int = 0):
        self.actions.move_to_element_with_offset(self.full_chart, x, y).perform()
        #print(f&#34;Moved cursor to ({x}, {y})&#34;)
        return None
                        
    def move_pointer(self, x_offset: int = None, y_offset: int = 1, x_increment: int = 1):
        &#34;&#34;&#34;Move cursor to a specific x-offset and y-offset from the chart element.
        Uses Selenium ActionChains to move the cursor.&#34;&#34;&#34;

        if x_offset is None:
            x = 0
            while x &lt; self.chart_x:
                self.move_cursor(x, y_offset)
                time.sleep(1)
                if self.get_tooltip_text():
                    break
                x += x_increment
            return True
        else:
            self.move_cursor(x, y_offset)
            time.sleep(1)
            if self.get_tooltip_text():
                return True
            else:
                return False
    
    def first_last_dates(self):
        &#34;&#34;&#34;Scrape first and last data points for the data series on the chart at TE using viewport coordinates.

        **Returns:**
        - start_end: dict containing the start and end dates and values of the data series.

        &#34;&#34;&#34;

        # try:
        self.update_chart()
        # determine_chart_method is inactive as of now...
        #self.determine_chart_type()
        self.select_line_chart() ## MAKE SURE IT IS A LINECHART.
        self.determine_date_span()

        if not hasattr(self, &#34;axes_rect&#34;):
            #print(&#34;Getting chart dimensions and plot background element.&#34;)
            if self.get_chart_dims():
                print(&#34;Got chart dimensions and plot background element.&#34;)

        # Calculate exact positions of left and right extremes
        left_x =  self.axes_rect[&#39;x&#39;] # Left edge x-coordinate
        right_x = self.axes_rect[&#39;x&#39;] + self.axes_rect[&#39;width&#39;] # Right edge x-coordinate
        y_pos = self.axes_rect[&#34;y&#34;] + round(self.axes_rect[&#34;height&#34;]/2)  # Middle of chart
        # NOTE: USING THE MIDDLE OF THE CHART (in Y) WILL REQUIRE LINE CHART_TYPE.
        
        # Initialize ActionChains
        actions = ActionChains(self.driver)
        start_end = {}
        
        # For each extreme (left and right)
        positions = {
            (&#34;start_date&#34;, &#34;start_value&#34;): left_x,
            (&#34;end_date&#34;, &#34;end_value&#34;): right_x
        }

        for (date_key, value_key), x_pos in positions.items():
            # Reset cursor by moving to plot background first
            actions.move_to_element(self.plot_background).perform()
            actions.reset_actions()
            
            # Move to exact position
            actions.move_by_offset(x_pos, y_pos).perform()
            #print(f&#34;Moved cursor to ({x_pos}, {y_pos})&#34;)
            time.sleep(0.5)
            
            # Get tooltip
            tooltip = self.get_tooltip_text()
            if tooltip:
                date, value = self.extract_date_value_tooltip(tooltip)
                if date and value:
                    start_end[date_key] = date
                    start_end[value_key] = value
        
        return start_end
            
    def get_latest_points(self, num_points: int = 5): #To do: The tooltip scraper class should perhaps inherit from this TE_SCraper so attrubutes such as datespan can be accessed.
        &#34;&#34;&#34; Scrape the latest points to determine the time-series frequency. Will also check if end_date is correct.
        This will work best if the chart is set to 1Y datespan first before the tooltip scraper object is initialized.

        **Parameters:**
        - num_points (int): The number of data points to scrape from the 1Y chart.

        **Returns:**

        - data_points (list): A list of dictionaries containing scraped data points.
        - num_points (int): The number of data points scraped.&#34;&#34;&#34;

        shortest_span = list(self.date_spans.keys())[0]
        if self.date_span != shortest_span: # Set the datespan to 1 year to look just at the latest data points
            self.set_date_span(shortest_span)
        
        self.select_line_chart() #Force line chart selection - very important.
        
        self.update_chart()
        if not hasattr(self, &#34;axes_rect&#34;):
            self.get_chart_dims()

        if not hasattr(self, &#34;viewport_width&#34;):
            self.viewport_width = self.driver.execute_script(&#34;return window.innerWidth;&#34;)
            self.viewport_height = self.driver.execute_script(&#34;return window.innerHeight;&#34;)
        
        data_points = []
        last_tooltip = &#34;&#34;
        viewport_y = self.axes_rect[&#39;y&#39;] + round(self.axes_rect[&#39;height&#39;] / 2)

        actions = ActionChains(self.driver); actions.reset_actions()
        # Move cursor to chart middle to start at right edge.
        chart_x = self.axes_rect[&#34;x&#34;]
        actions.move_to_element_with_offset(self.plot_background, round(self.chart_x/2), 0).perform()
        chart_edge = chart_x + round(self.chart_x/2); print(chart_edge)
        i = 1
        while len(data_points) &lt; num_points:
            try: 
                actions.move_by_offset(-i, 0).perform()
                time.sleep(0.05)
                
                tooltip = self.get_tooltip_text()
                date, value = self.extract_date_value_tooltip(tooltip)
                
                if tooltip == last_tooltip:
                    #print(f&#34;Date not changed from last point, skipping: {date}&#34;)
                    i += 1
                    continue

                if tooltip and date and value:
                    #print(&#34;Data point scraped: &#34;, date, value)  
                    data_points.append({
                        &#39;viewport_x&#39;: self.axes_rect[&#34;x&#34;] + i,
                        &#39;viewport_y&#39;: viewport_y,
                        &#39;tooltip_data&#39;: tooltip,
                        &#34;date&#34;: date,
                        &#34;value&#34;: value
                    })
                    i += 1
                else:
                    print(f&#34;No tooltip found at point&#34;)
            except Exception as e:
                logger.info(f&#34;Iteration {i}, error scraping data point at {chart_x} + {i}, {viewport_y}: {str(e)}&#34;)
                logger.info(&#34;We may have got enough points though already to determine the frequency, returning points.&#34;)
                return data_points
            last_tooltip = tooltip
        
        return data_points
    
    def get_device_pixel_ratio(self):
        &#34;&#34;&#34;Get device pixel ratio to scale movements&#34;&#34;&#34;
        return self.driver.execute_script(&#39;return window.devicePixelRatio;&#39;)
        
    def extract_date_value_tooltip(self, tooltip_element: str):
        &#34;&#34;&#34;Extract date and value from a single tooltip HTML&#34;&#34;&#34;

        # try:
        # Parse tooltip HTML
        soup = BeautifulSoup(tooltip_element, &#39;html.parser&#39;)
        
        # Extract date and value
        date = soup.select_one(&#39;.tooltip-date&#39;).text.strip()
        date = ready_datestr(date)
        
        value = soup.select_one(&#39;.tooltip-value&#39;).text.replace(&#39; Points&#39;, &#39;&#39;)
        #print(&#34;Date: &#34;, date, &#34;Value: &#34;, value)
        try:
            value = float(value)
        except:
            pass
        
        try:
            date = pd.to_datetime(date)
        except:
            print(f&#34;Error converting date string: {date}&#34;)
            pass
        
        # try:
        splitted = split_numeric(value)
        if isinstance(splitted, tuple):
            value = convert_metric_prefix(splitted[0])
        else:
            value = splitted

            # except Exception as e:
            #     print(f&#34;Error converting value string: {value}&#34;)
            #     return
            
        # except Exception as e:
        #     print(f&#34;Error parsing tooltip data: {str(e)}&#34;)
        #     return None
    
        return date, value
        
    def scrape_chart_data(self):
        &#34;&#34;&#34;Scrape data points by moving cursor across chart within viewport bounds
        I don&#39;t know if this is working atm, this approcach of pulling each datapoint one at a time from the tooltips
        may be implemented later yet it will need javascript implementation to work fast enough.
        Currently this is very slow when done this way. &#34;&#34;&#34;

        self.update_chart()
        
        # Get chart dimensions and position
        chart_rect = self.full_chart.rect
        chart_width = chart_rect[&#39;width&#39;]
        chart_height = chart_rect[&#39;height&#39;]
        
        # Find chart center in viewport coordinates
        chart_center_x = chart_rect[&#39;x&#39;] + (chart_width / 2)
        chart_center_y = chart_rect[&#39;y&#39;] + (chart_height / 2)
        print(f&#34;Chart center: ({chart_center_x}, {chart_center_y})&#34;)
        
        # Calculate valid x-coordinate range
        x_start = chart_center_x - (chart_width / 2)  # Leftmost valid x
        x_end = chart_center_x + (chart_width / 2)    # Rightmost valid x
        
        # Initialize data collection
        data_points = []
        x_increment = 2
        
        # Move cursor left to right within valid range
        current_x = x_start

        while current_x &lt;= x_end:
            try:
                # Calculate offset from chart center
                x_offset = current_x - chart_center_x
                
                # Move cursor using offset from center
                self.actions.move_to_element(self.full_chart)\
                        .move_by_offset(x_offset, 0)\
                        .perform()
                
                time.sleep(0.2)
                
                # Get tooltip data
                tooltip = self.get_tooltip_text()
                if tooltip:
                    data_points.append({
                        &#39;x_position&#39;: current_x,
                        &#39;tooltip_data&#39;: tooltip
                    })
                
                current_x += x_increment
                
            except Exception as e:
                print(f&#34;Error at x={current_x}: {str(e)}&#34;)
                current_x += x_increment
                
        return data_points

    def get_tooltip_text(self, tooltip_selector: str = &#39;.highcharts-tooltip&#39;):
        &#34;&#34;&#34;Get tooltip text from the chart element&#34;&#34;&#34;

        # Locate the tooltip element and extract the text
        tooltip_elements = self.driver.find_elements(By.CSS_SELECTOR, tooltip_selector)
        if tooltip_elements:
            for tooltip_element in tooltip_elements:
                tooltip_text = tooltip_element.get_attribute(&#34;outerHTML&#34;)
                #print(tooltip_text)
            return tooltip_text
        else:
            #print(&#34;Tooltip not found&#34;)
            return None
        
        
    def show_position_marker(self, x: int, y: int, duration_ms: int = 5000):
        &#34;&#34;&#34;Add visual marker at specified coordinates&#34;&#34;&#34;
        js_code = &#34;&#34;&#34;
            // Create dot element
            const dot = document.createElement(&#39;div&#39;);
            dot.style.cssText = `
                position: absolute;
                left: ${arguments[0]}px;
                top: ${arguments[1]}px;
                width: 10px;
                height: 10px;
                background-color: red;
                border-radius: 50%;
                z-index: 9999;
                pointer-events: none;
            `;
            document.body.appendChild(dot);
            
            // Remove after duration
            setTimeout(() =&gt; dot.remove(), arguments[2]);
        &#34;&#34;&#34;
        self.driver.execute_script(js_code, x, y, duration_ms)

    def mark_cursor_position(self, duration_ms: int = 5000):
        &#34;&#34;&#34;Mark current cursor position with dot&#34;&#34;&#34;
        js_code = &#34;&#34;&#34;
            let cursor_x = 0;
            let cursor_y = 0;
            
            document.addEventListener(&#39;mousemove&#39;, function(e) {
                cursor_x = e.pageX;
                cursor_y = e.pageY;
            });
            
            return [cursor_x, cursor_y];
        &#34;&#34;&#34;
        coords = self.driver.execute_script(js_code)
        if coords and len(coords) == 2:
            self.show_position_marker(coords[0], coords[1], duration_ms)
            return coords
        return None

    def move_cursor_on_chart(self, x: int = 0, y: int = 0):
        &#34;&#34;&#34;Move cursor to chart origin (0,0) point&#34;&#34;&#34;
        
        print(f&#34;Chart rect: {self.axes_rect}&#34;)
        # Calculate origin coordinates in viewport
        x_pos = self.full_chart.rect[&#34;x&#34;] + float(self.axes_rect[&#39;x&#39;])  + x
        y_pos = self.full_chart.rect[&#34;y&#34;] + float(self.axes_rect[&#39;y&#39;]) + float(self.axes_rect[&#34;height&#34;]) - y  
        
        # Move to origin
        actions = ActionChains(self.driver)
        actions.move_by_offset(x_pos, y_pos).perform()
        actions.reset_actions()
        self.show_position_marker(x_pos, y_pos)
        print(f&#34;Moved cursor to chart pposition ({x_pos}, {y_pos})&#34;)
    
    def bail_out(self):
        self.driver.quit()
        return None
    
    def move_with_marker(self, x: int, y: int):
        &#34;&#34;&#34;Move to position and show marker&#34;&#34;&#34;
        actions = ActionChains(self.driver)
        actions.move_by_offset(x, y).perform()
        actions.reset_actions()
        self.show_position_marker(x, y)</code></pre>
</details>
<div class="desc"><p>Extended version of TE_Scraper with additional functionality to scrape tooltip data from a chart element using Selenium.
Can be initilized using a TE_Scraper object or a new URL. If using a new URL, a new webdriver will be created. If using an existing
TE_Scraper object, the webdriver from that object will be used and all attributes will be copied over.
This can get x, y data from the tooltip box displayed by a site such as Trading Economics when the cursor
is moved over a chart. It can move the cursor to specific points on the chart and extract tooltip text.
It extracts date and value data from the tooltip text.
Initialize the scraper with a URL and chart coordinates</p>
<p><strong>init Parameters:</strong>
- parent_instance (scraper.TE_Scraper): A parent scraper object to copy attributes from. This is the most efficient way to initialize.
- **kwargs: Keyword arguments to pass to the parent class, these are TE_Scraper init key word arguments.
Generally you would not supply keyword arguments if you are using a parent_instance for initilization. The kwargs apply to creation
of a new TE_Scraper object. See TE_scraper class for details on initialization of a fresh instance.</p>
<p>Initialize the TooltipScraper object</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tedata.scraper.TE_Scraper" href="scraper.html#tedata.scraper.TE_Scraper">TE_Scraper</a></li>
<li><a title="tedata.base.Generic_Webdriver" href="base.html#tedata.base.Generic_Webdriver">Generic_Webdriver</a></li>
<li><a title="tedata.base.SharedWebDriverState" href="base.html#tedata.base.SharedWebDriverState">SharedWebDriverState</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tedata.utils.TooltipScraper.bail_out"><code class="name flex">
<span>def <span class="ident">bail_out</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bail_out(self):
    self.driver.quit()
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tedata.utils.TooltipScraper.extract_date_value_tooltip"><code class="name flex">
<span>def <span class="ident">extract_date_value_tooltip</span></span>(<span>self, tooltip_element: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_date_value_tooltip(self, tooltip_element: str):
    &#34;&#34;&#34;Extract date and value from a single tooltip HTML&#34;&#34;&#34;

    # try:
    # Parse tooltip HTML
    soup = BeautifulSoup(tooltip_element, &#39;html.parser&#39;)
    
    # Extract date and value
    date = soup.select_one(&#39;.tooltip-date&#39;).text.strip()
    date = ready_datestr(date)
    
    value = soup.select_one(&#39;.tooltip-value&#39;).text.replace(&#39; Points&#39;, &#39;&#39;)
    #print(&#34;Date: &#34;, date, &#34;Value: &#34;, value)
    try:
        value = float(value)
    except:
        pass
    
    try:
        date = pd.to_datetime(date)
    except:
        print(f&#34;Error converting date string: {date}&#34;)
        pass
    
    # try:
    splitted = split_numeric(value)
    if isinstance(splitted, tuple):
        value = convert_metric_prefix(splitted[0])
    else:
        value = splitted

        # except Exception as e:
        #     print(f&#34;Error converting value string: {value}&#34;)
        #     return
        
    # except Exception as e:
    #     print(f&#34;Error parsing tooltip data: {str(e)}&#34;)
    #     return None

    return date, value</code></pre>
</details>
<div class="desc"><p>Extract date and value from a single tooltip HTML</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.first_last_dates"><code class="name flex">
<span>def <span class="ident">first_last_dates</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_last_dates(self):
    &#34;&#34;&#34;Scrape first and last data points for the data series on the chart at TE using viewport coordinates.

    **Returns:**
    - start_end: dict containing the start and end dates and values of the data series.

    &#34;&#34;&#34;

    # try:
    self.update_chart()
    # determine_chart_method is inactive as of now...
    #self.determine_chart_type()
    self.select_line_chart() ## MAKE SURE IT IS A LINECHART.
    self.determine_date_span()

    if not hasattr(self, &#34;axes_rect&#34;):
        #print(&#34;Getting chart dimensions and plot background element.&#34;)
        if self.get_chart_dims():
            print(&#34;Got chart dimensions and plot background element.&#34;)

    # Calculate exact positions of left and right extremes
    left_x =  self.axes_rect[&#39;x&#39;] # Left edge x-coordinate
    right_x = self.axes_rect[&#39;x&#39;] + self.axes_rect[&#39;width&#39;] # Right edge x-coordinate
    y_pos = self.axes_rect[&#34;y&#34;] + round(self.axes_rect[&#34;height&#34;]/2)  # Middle of chart
    # NOTE: USING THE MIDDLE OF THE CHART (in Y) WILL REQUIRE LINE CHART_TYPE.
    
    # Initialize ActionChains
    actions = ActionChains(self.driver)
    start_end = {}
    
    # For each extreme (left and right)
    positions = {
        (&#34;start_date&#34;, &#34;start_value&#34;): left_x,
        (&#34;end_date&#34;, &#34;end_value&#34;): right_x
    }

    for (date_key, value_key), x_pos in positions.items():
        # Reset cursor by moving to plot background first
        actions.move_to_element(self.plot_background).perform()
        actions.reset_actions()
        
        # Move to exact position
        actions.move_by_offset(x_pos, y_pos).perform()
        #print(f&#34;Moved cursor to ({x_pos}, {y_pos})&#34;)
        time.sleep(0.5)
        
        # Get tooltip
        tooltip = self.get_tooltip_text()
        if tooltip:
            date, value = self.extract_date_value_tooltip(tooltip)
            if date and value:
                start_end[date_key] = date
                start_end[value_key] = value
    
    return start_end</code></pre>
</details>
<div class="desc"><p>Scrape first and last data points for the data series on the chart at TE using viewport coordinates.</p>
<p><strong>Returns:</strong>
- start_end: dict containing the start and end dates and values of the data series.</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.get_chart_dims"><code class="name flex">
<span>def <span class="ident">get_chart_dims</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chart_dims(self):
    &#34;&#34;&#34;Get dimensions of chart and plotting area&#34;&#34;&#34;
    try:
        # Ensure full_chart is WebElement
        self.chart_element = self.driver.find_element(By.CSS_SELECTOR, &#34;#chart&#34;)
            
        # Get overall chart dimensions
        self.chart_rect = {k: round(float(v), 1) for k, v in self.chart_element.rect.items()}
        
        # Get plot area dimensions
        self.plot_background = self.driver.find_element(By.CSS_SELECTOR, &#39;.highcharts-plot-background&#39;)
        self.axes_rect = {k: round(float(v), 1) for k, v in self.plot_background.rect.items()}
        self.chart_x = self.axes_rect[&#34;width&#34;]
        self.chart_y = self.axes_rect[&#34;height&#34;]
        return True
    
    except Exception as e:
        print(f&#34;Failed to get chart dimensions: {e}&#34;)
        logger.error(f&#34;Failed to get chart dimensions: {e}&#34;)
        return False</code></pre>
</details>
<div class="desc"><p>Get dimensions of chart and plotting area</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.get_device_pixel_ratio"><code class="name flex">
<span>def <span class="ident">get_device_pixel_ratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_device_pixel_ratio(self):
    &#34;&#34;&#34;Get device pixel ratio to scale movements&#34;&#34;&#34;
    return self.driver.execute_script(&#39;return window.devicePixelRatio;&#39;)</code></pre>
</details>
<div class="desc"><p>Get device pixel ratio to scale movements</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.get_latest_points"><code class="name flex">
<span>def <span class="ident">get_latest_points</span></span>(<span>self, num_points: int = 5)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_points(self, num_points: int = 5): #To do: The tooltip scraper class should perhaps inherit from this TE_SCraper so attrubutes such as datespan can be accessed.
    &#34;&#34;&#34; Scrape the latest points to determine the time-series frequency. Will also check if end_date is correct.
    This will work best if the chart is set to 1Y datespan first before the tooltip scraper object is initialized.

    **Parameters:**
    - num_points (int): The number of data points to scrape from the 1Y chart.

    **Returns:**

    - data_points (list): A list of dictionaries containing scraped data points.
    - num_points (int): The number of data points scraped.&#34;&#34;&#34;

    shortest_span = list(self.date_spans.keys())[0]
    if self.date_span != shortest_span: # Set the datespan to 1 year to look just at the latest data points
        self.set_date_span(shortest_span)
    
    self.select_line_chart() #Force line chart selection - very important.
    
    self.update_chart()
    if not hasattr(self, &#34;axes_rect&#34;):
        self.get_chart_dims()

    if not hasattr(self, &#34;viewport_width&#34;):
        self.viewport_width = self.driver.execute_script(&#34;return window.innerWidth;&#34;)
        self.viewport_height = self.driver.execute_script(&#34;return window.innerHeight;&#34;)
    
    data_points = []
    last_tooltip = &#34;&#34;
    viewport_y = self.axes_rect[&#39;y&#39;] + round(self.axes_rect[&#39;height&#39;] / 2)

    actions = ActionChains(self.driver); actions.reset_actions()
    # Move cursor to chart middle to start at right edge.
    chart_x = self.axes_rect[&#34;x&#34;]
    actions.move_to_element_with_offset(self.plot_background, round(self.chart_x/2), 0).perform()
    chart_edge = chart_x + round(self.chart_x/2); print(chart_edge)
    i = 1
    while len(data_points) &lt; num_points:
        try: 
            actions.move_by_offset(-i, 0).perform()
            time.sleep(0.05)
            
            tooltip = self.get_tooltip_text()
            date, value = self.extract_date_value_tooltip(tooltip)
            
            if tooltip == last_tooltip:
                #print(f&#34;Date not changed from last point, skipping: {date}&#34;)
                i += 1
                continue

            if tooltip and date and value:
                #print(&#34;Data point scraped: &#34;, date, value)  
                data_points.append({
                    &#39;viewport_x&#39;: self.axes_rect[&#34;x&#34;] + i,
                    &#39;viewport_y&#39;: viewport_y,
                    &#39;tooltip_data&#39;: tooltip,
                    &#34;date&#34;: date,
                    &#34;value&#34;: value
                })
                i += 1
            else:
                print(f&#34;No tooltip found at point&#34;)
        except Exception as e:
            logger.info(f&#34;Iteration {i}, error scraping data point at {chart_x} + {i}, {viewport_y}: {str(e)}&#34;)
            logger.info(&#34;We may have got enough points though already to determine the frequency, returning points.&#34;)
            return data_points
        last_tooltip = tooltip
    
    return data_points</code></pre>
</details>
<div class="desc"><p>Scrape the latest points to determine the time-series frequency. Will also check if end_date is correct.
This will work best if the chart is set to 1Y datespan first before the tooltip scraper object is initialized.</p>
<p><strong>Parameters:</strong>
- num_points (int): The number of data points to scrape from the 1Y chart.</p>
<p><strong>Returns:</strong></p>
<ul>
<li>data_points (list): A list of dictionaries containing scraped data points.</li>
<li>num_points (int): The number of data points scraped.</li>
</ul></div>
</dd>
<dt id="tedata.utils.TooltipScraper.get_tooltip_text"><code class="name flex">
<span>def <span class="ident">get_tooltip_text</span></span>(<span>self, tooltip_selector: str = '.highcharts-tooltip')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tooltip_text(self, tooltip_selector: str = &#39;.highcharts-tooltip&#39;):
    &#34;&#34;&#34;Get tooltip text from the chart element&#34;&#34;&#34;

    # Locate the tooltip element and extract the text
    tooltip_elements = self.driver.find_elements(By.CSS_SELECTOR, tooltip_selector)
    if tooltip_elements:
        for tooltip_element in tooltip_elements:
            tooltip_text = tooltip_element.get_attribute(&#34;outerHTML&#34;)
            #print(tooltip_text)
        return tooltip_text
    else:
        #print(&#34;Tooltip not found&#34;)
        return None</code></pre>
</details>
<div class="desc"><p>Get tooltip text from the chart element</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.mark_cursor_position"><code class="name flex">
<span>def <span class="ident">mark_cursor_position</span></span>(<span>self, duration_ms: int = 5000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_cursor_position(self, duration_ms: int = 5000):
    &#34;&#34;&#34;Mark current cursor position with dot&#34;&#34;&#34;
    js_code = &#34;&#34;&#34;
        let cursor_x = 0;
        let cursor_y = 0;
        
        document.addEventListener(&#39;mousemove&#39;, function(e) {
            cursor_x = e.pageX;
            cursor_y = e.pageY;
        });
        
        return [cursor_x, cursor_y];
    &#34;&#34;&#34;
    coords = self.driver.execute_script(js_code)
    if coords and len(coords) == 2:
        self.show_position_marker(coords[0], coords[1], duration_ms)
        return coords
    return None</code></pre>
</details>
<div class="desc"><p>Mark current cursor position with dot</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.move_cursor"><code class="name flex">
<span>def <span class="ident">move_cursor</span></span>(<span>self, x: int = 0, y: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor(self, x: int = 0, y: int = 0):
    self.actions.move_to_element_with_offset(self.full_chart, x, y).perform()
    #print(f&#34;Moved cursor to ({x}, {y})&#34;)
    return None</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tedata.utils.TooltipScraper.move_cursor_on_chart"><code class="name flex">
<span>def <span class="ident">move_cursor_on_chart</span></span>(<span>self, x: int = 0, y: int = 0)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_cursor_on_chart(self, x: int = 0, y: int = 0):
    &#34;&#34;&#34;Move cursor to chart origin (0,0) point&#34;&#34;&#34;
    
    print(f&#34;Chart rect: {self.axes_rect}&#34;)
    # Calculate origin coordinates in viewport
    x_pos = self.full_chart.rect[&#34;x&#34;] + float(self.axes_rect[&#39;x&#39;])  + x
    y_pos = self.full_chart.rect[&#34;y&#34;] + float(self.axes_rect[&#39;y&#39;]) + float(self.axes_rect[&#34;height&#34;]) - y  
    
    # Move to origin
    actions = ActionChains(self.driver)
    actions.move_by_offset(x_pos, y_pos).perform()
    actions.reset_actions()
    self.show_position_marker(x_pos, y_pos)
    print(f&#34;Moved cursor to chart pposition ({x_pos}, {y_pos})&#34;)</code></pre>
</details>
<div class="desc"><p>Move cursor to chart origin (0,0) point</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.move_pointer"><code class="name flex">
<span>def <span class="ident">move_pointer</span></span>(<span>self, x_offset: int = None, y_offset: int = 1, x_increment: int = 1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_pointer(self, x_offset: int = None, y_offset: int = 1, x_increment: int = 1):
    &#34;&#34;&#34;Move cursor to a specific x-offset and y-offset from the chart element.
    Uses Selenium ActionChains to move the cursor.&#34;&#34;&#34;

    if x_offset is None:
        x = 0
        while x &lt; self.chart_x:
            self.move_cursor(x, y_offset)
            time.sleep(1)
            if self.get_tooltip_text():
                break
            x += x_increment
        return True
    else:
        self.move_cursor(x, y_offset)
        time.sleep(1)
        if self.get_tooltip_text():
            return True
        else:
            return False</code></pre>
</details>
<div class="desc"><p>Move cursor to a specific x-offset and y-offset from the chart element.
Uses Selenium ActionChains to move the cursor.</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.move_with_marker"><code class="name flex">
<span>def <span class="ident">move_with_marker</span></span>(<span>self, x: int, y: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_with_marker(self, x: int, y: int):
    &#34;&#34;&#34;Move to position and show marker&#34;&#34;&#34;
    actions = ActionChains(self.driver)
    actions.move_by_offset(x, y).perform()
    actions.reset_actions()
    self.show_position_marker(x, y)</code></pre>
</details>
<div class="desc"><p>Move to position and show marker</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.scrape_chart_data"><code class="name flex">
<span>def <span class="ident">scrape_chart_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scrape_chart_data(self):
    &#34;&#34;&#34;Scrape data points by moving cursor across chart within viewport bounds
    I don&#39;t know if this is working atm, this approcach of pulling each datapoint one at a time from the tooltips
    may be implemented later yet it will need javascript implementation to work fast enough.
    Currently this is very slow when done this way. &#34;&#34;&#34;

    self.update_chart()
    
    # Get chart dimensions and position
    chart_rect = self.full_chart.rect
    chart_width = chart_rect[&#39;width&#39;]
    chart_height = chart_rect[&#39;height&#39;]
    
    # Find chart center in viewport coordinates
    chart_center_x = chart_rect[&#39;x&#39;] + (chart_width / 2)
    chart_center_y = chart_rect[&#39;y&#39;] + (chart_height / 2)
    print(f&#34;Chart center: ({chart_center_x}, {chart_center_y})&#34;)
    
    # Calculate valid x-coordinate range
    x_start = chart_center_x - (chart_width / 2)  # Leftmost valid x
    x_end = chart_center_x + (chart_width / 2)    # Rightmost valid x
    
    # Initialize data collection
    data_points = []
    x_increment = 2
    
    # Move cursor left to right within valid range
    current_x = x_start

    while current_x &lt;= x_end:
        try:
            # Calculate offset from chart center
            x_offset = current_x - chart_center_x
            
            # Move cursor using offset from center
            self.actions.move_to_element(self.full_chart)\
                    .move_by_offset(x_offset, 0)\
                    .perform()
            
            time.sleep(0.2)
            
            # Get tooltip data
            tooltip = self.get_tooltip_text()
            if tooltip:
                data_points.append({
                    &#39;x_position&#39;: current_x,
                    &#39;tooltip_data&#39;: tooltip
                })
            
            current_x += x_increment
            
        except Exception as e:
            print(f&#34;Error at x={current_x}: {str(e)}&#34;)
            current_x += x_increment
            
    return data_points</code></pre>
</details>
<div class="desc"><p>Scrape data points by moving cursor across chart within viewport bounds
I don't know if this is working atm, this approcach of pulling each datapoint one at a time from the tooltips
may be implemented later yet it will need javascript implementation to work fast enough.
Currently this is very slow when done this way.</p></div>
</dd>
<dt id="tedata.utils.TooltipScraper.show_position_marker"><code class="name flex">
<span>def <span class="ident">show_position_marker</span></span>(<span>self, x: int, y: int, duration_ms: int = 5000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_position_marker(self, x: int, y: int, duration_ms: int = 5000):
    &#34;&#34;&#34;Add visual marker at specified coordinates&#34;&#34;&#34;
    js_code = &#34;&#34;&#34;
        // Create dot element
        const dot = document.createElement(&#39;div&#39;);
        dot.style.cssText = `
            position: absolute;
            left: ${arguments[0]}px;
            top: ${arguments[1]}px;
            width: 10px;
            height: 10px;
            background-color: red;
            border-radius: 50%;
            z-index: 9999;
            pointer-events: none;
        `;
        document.body.appendChild(dot);
        
        // Remove after duration
        setTimeout(() =&gt; dot.remove(), arguments[2]);
    &#34;&#34;&#34;
    self.driver.execute_script(js_code, x, y, duration_ms)</code></pre>
</details>
<div class="desc"><p>Add visual marker at specified coordinates</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tedata.scraper.TE_Scraper" href="scraper.html#tedata.scraper.TE_Scraper">TE_Scraper</a></b></code>:
<ul class="hlist">
<li><code><a title="tedata.scraper.TE_Scraper.apply_x_index" href="scraper.html#tedata.scraper.TE_Scraper.apply_x_index">apply_x_index</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.click_button" href="scraper.html#tedata.scraper.TE_Scraper.click_button">click_button</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.click_max_button" href="scraper.html#tedata.scraper.TE_Scraper.click_max_button">click_max_button</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.close" href="scraper.html#tedata.scraper.TE_Scraper.close">close</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.create_chart_types_dict" href="scraper.html#tedata.scraper.TE_Scraper.create_chart_types_dict">create_chart_types_dict</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.custom_date_span" href="scraper.html#tedata.scraper.TE_Scraper.custom_date_span">custom_date_span</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.determine_date_span" href="scraper.html#tedata.scraper.TE_Scraper.determine_date_span">determine_date_span</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.dtIndex" href="scraper.html#tedata.scraper.TE_Scraper.dtIndex">dtIndex</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.extract_axis_limits" href="scraper.html#tedata.scraper.TE_Scraper.extract_axis_limits">extract_axis_limits</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.find_max_button" href="scraper.html#tedata.scraper.TE_Scraper.find_max_button">find_max_button</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.get_datamax_min" href="scraper.html#tedata.scraper.TE_Scraper.get_datamax_min">get_datamax_min</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.get_element" href="scraper.html#tedata.scraper.TE_Scraper.get_element">get_element</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.get_page_source" href="scraper.html#tedata.scraper.TE_Scraper.get_page_source">get_page_source</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.get_xlims_from_tooltips" href="scraper.html#tedata.scraper.TE_Scraper.get_xlims_from_tooltips">get_xlims_from_tooltips</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.get_y_axis" href="scraper.html#tedata.scraper.TE_Scraper.get_y_axis">get_y_axis</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.load_page" href="scraper.html#tedata.scraper.TE_Scraper.load_page">load_page</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.make_x_index" href="scraper.html#tedata.scraper.TE_Scraper.make_x_index">make_x_index</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.plot_series" href="scraper.html#tedata.scraper.TE_Scraper.plot_series">plot_series</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.save_plot" href="scraper.html#tedata.scraper.TE_Scraper.save_plot">save_plot</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.scale_series" href="scraper.html#tedata.scraper.TE_Scraper.scale_series">scale_series</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.scrape_metadata" href="scraper.html#tedata.scraper.TE_Scraper.scrape_metadata">scrape_metadata</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.select_chart_type" href="scraper.html#tedata.scraper.TE_Scraper.select_chart_type">select_chart_type</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.select_line_chart" href="scraper.html#tedata.scraper.TE_Scraper.select_line_chart">select_line_chart</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.series_from_chart_soup" href="scraper.html#tedata.scraper.TE_Scraper.series_from_chart_soup">series_from_chart_soup</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.set_date_span" href="scraper.html#tedata.scraper.TE_Scraper.set_date_span">set_date_span</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.update_chart" href="scraper.html#tedata.scraper.TE_Scraper.update_chart">update_chart</a></code></li>
<li><code><a title="tedata.scraper.TE_Scraper.update_date_span" href="scraper.html#tedata.scraper.TE_Scraper.update_date_span">update_date_span</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tedata" href="index.html">tedata</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tedata.utils.check_browser_installed" href="#tedata.utils.check_browser_installed">check_browser_installed</a></code></li>
<li><code><a title="tedata.utils.check_element_exists_bs4" href="#tedata.utils.check_element_exists_bs4">check_element_exists_bs4</a></code></li>
<li><code><a title="tedata.utils.click_button" href="#tedata.utils.click_button">click_button</a></code></li>
<li><code><a title="tedata.utils.convert_metric_prefix" href="#tedata.utils.convert_metric_prefix">convert_metric_prefix</a></code></li>
<li><code><a title="tedata.utils.export_html" href="#tedata.utils.export_html">export_html</a></code></li>
<li><code><a title="tedata.utils.find_zero_crossing" href="#tedata.utils.find_zero_crossing">find_zero_crossing</a></code></li>
<li><code><a title="tedata.utils.get_chart_datespans" href="#tedata.utils.get_chart_datespans">get_chart_datespans</a></code></li>
<li><code><a title="tedata.utils.get_date_frequency" href="#tedata.utils.get_date_frequency">get_date_frequency</a></code></li>
<li><code><a title="tedata.utils.invert_series" href="#tedata.utils.invert_series">invert_series</a></code></li>
<li><code><a title="tedata.utils.map_frequency" href="#tedata.utils.map_frequency">map_frequency</a></code></li>
<li><code><a title="tedata.utils.normalize_series" href="#tedata.utils.normalize_series">normalize_series</a></code></li>
<li><code><a title="tedata.utils.ready_datestr" href="#tedata.utils.ready_datestr">ready_datestr</a></code></li>
<li><code><a title="tedata.utils.round_to_freq" href="#tedata.utils.round_to_freq">round_to_freq</a></code></li>
<li><code><a title="tedata.utils.round_to_month_start" href="#tedata.utils.round_to_month_start">round_to_month_start</a></code></li>
<li><code><a title="tedata.utils.show_position_marker" href="#tedata.utils.show_position_marker">show_position_marker</a></code></li>
<li><code><a title="tedata.utils.split_numeric" href="#tedata.utils.split_numeric">split_numeric</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tedata.utils.TooltipScraper" href="#tedata.utils.TooltipScraper">TooltipScraper</a></code></h4>
<ul class="">
<li><code><a title="tedata.utils.TooltipScraper.bail_out" href="#tedata.utils.TooltipScraper.bail_out">bail_out</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.extract_date_value_tooltip" href="#tedata.utils.TooltipScraper.extract_date_value_tooltip">extract_date_value_tooltip</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.first_last_dates" href="#tedata.utils.TooltipScraper.first_last_dates">first_last_dates</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.get_chart_dims" href="#tedata.utils.TooltipScraper.get_chart_dims">get_chart_dims</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.get_device_pixel_ratio" href="#tedata.utils.TooltipScraper.get_device_pixel_ratio">get_device_pixel_ratio</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.get_latest_points" href="#tedata.utils.TooltipScraper.get_latest_points">get_latest_points</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.get_tooltip_text" href="#tedata.utils.TooltipScraper.get_tooltip_text">get_tooltip_text</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.mark_cursor_position" href="#tedata.utils.TooltipScraper.mark_cursor_position">mark_cursor_position</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.move_cursor" href="#tedata.utils.TooltipScraper.move_cursor">move_cursor</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.move_cursor_on_chart" href="#tedata.utils.TooltipScraper.move_cursor_on_chart">move_cursor_on_chart</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.move_pointer" href="#tedata.utils.TooltipScraper.move_pointer">move_pointer</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.move_with_marker" href="#tedata.utils.TooltipScraper.move_with_marker">move_with_marker</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.scrape_chart_data" href="#tedata.utils.TooltipScraper.scrape_chart_data">scrape_chart_data</a></code></li>
<li><code><a title="tedata.utils.TooltipScraper.show_position_marker" href="#tedata.utils.TooltipScraper.show_position_marker">show_position_marker</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
