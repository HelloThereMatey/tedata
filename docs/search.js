window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "tedata", "modulename": "tedata", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.logger", "modulename": "tedata", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.scrape_chart (DEBUG)&gt;"}, {"fullname": "tedata.base", "modulename": "tedata.base", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.base.logger", "modulename": "tedata.base", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.base (DEBUG)&gt;"}, {"fullname": "tedata.base.find_active_drivers", "modulename": "tedata.base", "qualname": "find_active_drivers", "kind": "function", "doc": "<p>Find all active selenium webdriver instances in memory sorted by age.</p>\n\n<p>Args:\n    quit_all (bool): If True, quit all found drivers and clear references\n    close_scrapers (bool): If True, also find and close any TE_Scraper objects</p>\n\n<p>Returns:\n    list: List of tuples (driver, age_in_seconds) sorted by age, excluding weakproxies</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">close_all_drivers</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">close__all_scrapers</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.base.TimestampedFirefox", "modulename": "tedata.base", "qualname": "TimestampedFirefox", "kind": "class", "doc": "<p>Controls the GeckoDriver and allows you to drive the browser.</p>\n", "bases": "selenium.webdriver.firefox.webdriver.WebDriver"}, {"fullname": "tedata.base.TimestampedFirefox.__init__", "modulename": "tedata.base", "qualname": "TimestampedFirefox.__init__", "kind": "function", "doc": "<p>Creates a new instance of the Firefox driver. Starts the service and\nthen creates new instance of Firefox driver.</p>\n\n<p>:Args:</p>\n\n<ul>\n<li>options - Instance of <code>options.Options</code>.</li>\n<li>service - (Optional) service instance for managing the starting and stopping of the driver.</li>\n<li>keep_alive - Whether to configure remote_connection.RemoteConnection to use HTTP keep-alive.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tedata.base.TimestampedFirefox.created_at", "modulename": "tedata.base", "qualname": "TimestampedFirefox.created_at", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.TimestampedChrome", "modulename": "tedata.base", "qualname": "TimestampedChrome", "kind": "class", "doc": "<p>Controls the ChromeDriver and allows you to drive the browser.</p>\n", "bases": "selenium.webdriver.chrome.webdriver.WebDriver"}, {"fullname": "tedata.base.TimestampedChrome.__init__", "modulename": "tedata.base", "qualname": "TimestampedChrome.__init__", "kind": "function", "doc": "<p>Creates a new instance of the chrome driver. Starts the service and\nthen creates new instance of chrome driver.</p>\n\n<p>:Args:</p>\n\n<ul>\n<li>options - this takes an instance of ChromeOptions</li>\n<li>service - Service object for handling the browser driver if you need to pass extra details</li>\n<li>keep_alive - Whether to configure ChromeRemoteConnection to use HTTP keep-alive.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tedata.base.TimestampedChrome.created_at", "modulename": "tedata.base", "qualname": "TimestampedChrome.created_at", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.Generic_Webdriver", "modulename": "tedata.base", "qualname": "Generic_Webdriver", "kind": "class", "doc": "<p>Generic webdriver class for initializing a Selenium WebDriver. This is the base class for the TE_Scraper and TooltipScraper classes.\nIt can be used to create a new webdriver or use an existing one. The browser type can be set to 'chrome' or 'firefox'.\nIt holds a wedbdriver object and a WebDriverWait object as components and has attributes that help keep track of things.</p>\n\n<p><strong>Init Parameters:</strong></p>\n\n<ul>\n<li>driver (webdriver): If provided, the class will use this webdriver instance instead of creating a new one.</li>\n<li>browser (str): The browser to use for the webdriver. Options are 'chrome' or 'firefox'.</li>\n<li>headless (bool): If True, the browser will run in headless mode.</li>\n<li>use_existing_driver (bool): If True, the class will attempt to use an existing 'spare' webdriver instance if one is found.</li>\n</ul>\n"}, {"fullname": "tedata.base.Generic_Webdriver.__init__", "modulename": "tedata.base", "qualname": "Generic_Webdriver.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">driver</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;selenium.webdriver&#39;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"s1\">&#39;/Users/jamesbishop/Documents/miniconda3/envs/ted/lib/python3.11/site-packages/selenium/webdriver/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">browser</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;chrome&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;firefox&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;firefox&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">headless</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_existing_driver</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "tedata.base.Generic_Webdriver.BrowserType", "modulename": "tedata.base", "qualname": "Generic_Webdriver.BrowserType", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Literal[&#x27;chrome&#x27;, &#x27;firefox&#x27;]"}, {"fullname": "tedata.base.Generic_Webdriver.browser", "modulename": "tedata.base", "qualname": "Generic_Webdriver.browser", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.Generic_Webdriver.headless", "modulename": "tedata.base", "qualname": "Generic_Webdriver.headless", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.Generic_Webdriver.wait", "modulename": "tedata.base", "qualname": "Generic_Webdriver.wait", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.Generic_Webdriver.created_at", "modulename": "tedata.base", "qualname": "Generic_Webdriver.created_at", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState", "modulename": "tedata.base", "qualname": "SharedWebDriverState", "kind": "class", "doc": "<p>Maintain shared state for classes that use the same webdriver.\nThis could be used as a mixin class or used via composition as an attribute shared by multiple classes.\nThis is used to share the webdriver state between the TE_Scraper and TooltipScraper classes.</p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.__init__", "modulename": "tedata.base", "qualname": "SharedWebDriverState.__init__", "kind": "function", "doc": "<p>Initialize shared state attributes, it is chart_type and date_span which we want to keep synced between the classes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">()</span>"}, {"fullname": "tedata.base.SharedWebDriverState.observers", "modulename": "tedata.base", "qualname": "SharedWebDriverState.observers", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.register", "modulename": "tedata.base", "qualname": "SharedWebDriverState.register", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">observer</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.base.SharedWebDriverState.page_source", "modulename": "tedata.base", "qualname": "SharedWebDriverState.page_source", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.page_soup", "modulename": "tedata.base", "qualname": "SharedWebDriverState.page_soup", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.chart_soup", "modulename": "tedata.base", "qualname": "SharedWebDriverState.chart_soup", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.full_chart", "modulename": "tedata.base", "qualname": "SharedWebDriverState.full_chart", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.date_span", "modulename": "tedata.base", "qualname": "SharedWebDriverState.date_span", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.SharedWebDriverState.chart_type", "modulename": "tedata.base", "qualname": "SharedWebDriverState.chart_type", "kind": "variable", "doc": "<p></p>\n"}, {"fullname": "tedata.base.setup_chrome_driver", "modulename": "tedata.base", "qualname": "setup_chrome_driver", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">headless</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.logger_setup", "modulename": "tedata.logger_setup", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.logger_setup.setup_logger", "modulename": "tedata.logger_setup", "qualname": "setup_logger", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scrape_chart", "modulename": "tedata.scrape_chart", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.scrape_chart.fdel", "modulename": "tedata.scrape_chart", "qualname": "fdel", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/&#x27;"}, {"fullname": "tedata.scrape_chart.wd", "modulename": "tedata.scrape_chart", "qualname": "wd", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/Users/jamesbishop/Documents/Python/Scraping/tedata/src/tedata&#x27;"}, {"fullname": "tedata.scrape_chart.logger", "modulename": "tedata.scrape_chart", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.scrape_chart (DEBUG)&gt;"}, {"fullname": "tedata.scrape_chart.scrape_chart", "modulename": "tedata.scrape_chart", "qualname": "scrape_chart", "kind": "function", "doc": "<p>This convenience function will scrape a chart from Trading Economics and return a TE_Scraper object with the series data in\nthe 'series' attribute. Metadata is also retreived and stored in the 'series_metadata' &amp; 'metadata' attributes.</p>\n\n<p><em>There are multiple ways to use this function:</em></p>\n\n<ul>\n<li>Supply URL of the chart to scrape OR supply country + indicator, or just id of the chart to scrape. country and indicator are the latter parts of the \nfull chart URL. e.g for URL: 'https://tradingeconomics.com/united-states/business-confidence', we could instead use country='united-states' \nand indicator ='business-confidence'. Or use id = \"united-states/business-confidence\". For US, you can supply just the indicator as the default country is \n'united-states'.</li>\n<li>You can leave scraper and driver as None and the function will create a new TE_Scraper object for that URL and use it to scrape the data.\nYou can however save time by passing either a scraper object or a driver object to the function. This is still somewhat experimental though \nand may not work.</li>\n</ul>\n\n<p><strong>Parameters</strong></p>\n\n<ul>\n<li>url (str): The URL of the chart to scrape.</li>\n<li>id (str): The id of the chart to scrape. This is the latter part of the URL after the base URL. e.g 'united-states/business-confidence'.</li>\n<li>country (str): The country of the chart to scrape. Default is 'united-states'.</li>\n<li>indicator (str): The indicator of the chart to scrape. Default is 'business-confidence'.</li>\n<li>start_date (str): The start date of the series to scrape. Use \"YYYY-MM-DD\" format. Only applies to the \"mixed\" method.\nDefault is None. If using None it will get max available date range.</li>\n<li>end_date (str): The end date of the series to scrape. Use \"YYYY-MM-DD\" format. Only applies to the \"mixed\" method. Default is None. \nIf using None it will get max available date range.\nCurrently start and end dates only apply when using the 'tooltips' method.</li>\n<li>method (str): The method to use to scrape the data. Default is 'path'. Other option is 'tooltips'. 'path' is the default method it uses, the path\nelement of the trace on the svg chart and then later scales the series using the y-axis values. 'tooltips' uses the tooltip box on the chart to get the\nwhole series data. The 'path' method is likely to work yet could have inacuraccies in values. The 'tooltips' method is more accurate. Try both and \ndecide what works best for you.</li>\n<li>scraper (TE_Scraper): A TE_Scraper object to use for scraping the data. If this is passed, the function will not create a new one.</li>\n<li>use_existing_driver (bool): Whether to use the existing webdriver of the scraper object if it exists. Default is False.</li>\n<li>driver (webdriver): A Selenium WebDriver object to use for scraping the data. If this is passed, the function will not create a new one. If \nscraper and driver are both passed, the webdriver of the scraper object will be used rather than the supplied webdriver.</li>\n<li>headless (bool): Whether to run the browser in headless mode (display no window).</li>\n<li>browser (str): The browser to use, either 'chrome' or 'firefox'. Default is 'firefox'. Only firefox is supported at the moment (v0.3.0).</li>\n</ul>\n\n<p><strong>Returns</strong></p>\n\n<ul>\n<li>TE_Scraper object with the scraped data or None if an error occurs.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">url</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"nb\">id</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;united-states/business-confidence&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">country</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;united-states&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">indicator</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;path&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;tooltips&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;mixed&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;path&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">scraper</span><span class=\"p\">:</span> <span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">scraper</span><span class=\"o\">.</span><span class=\"n\">TE_Scraper</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">driver</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;selenium.webdriver&#39;</span> <span class=\"kn\">from</span><span class=\"w\"> </span><span class=\"s1\">&#39;/Users/jamesbishop/Documents/miniconda3/envs/ted/lib/python3.11/site-packages/selenium/webdriver/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_existing_driver</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">headless</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">browser</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;firefox&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">scraper</span><span class=\"o\">.</span><span class=\"n\">TE_Scraper</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper", "modulename": "tedata.scraper", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.scraper.fdel", "modulename": "tedata.scraper", "qualname": "fdel", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/&#x27;"}, {"fullname": "tedata.scraper.logger", "modulename": "tedata.scraper", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.scraper (DEBUG)&gt;"}, {"fullname": "tedata.scraper.find_element_header_match", "modulename": "tedata.scraper", "qualname": "find_element_header_match", "kind": "function", "doc": "<p>Find .card-header element with text matching search_text</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">soup</span><span class=\"p\">:</span> <span class=\"n\">bs4</span><span class=\"o\">.</span><span class=\"n\">BeautifulSoup</span>, </span><span class=\"param\"><span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">match_text</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper", "modulename": "tedata.scraper", "qualname": "TE_Scraper", "kind": "class", "doc": "<p>Class for scraping data from Trading Economics website. This is the main workhorse of the module.\nIt is designed to scrape data from the Trading Economics website using Selenium and BeautifulSoup.\nIt can load a page, click buttons, extract data from elements, and plot the extracted data. Uses multiple inheritance\nfrom the Generic_Webdriver and SharedWebDriverState classes. This enables creation of TooltipScraper child classes that have \nsynced atributes such as \"chart_soup\", \"chart_type\" &amp; \"date_span\" &amp; share the same webdriver object. This is useful for scraping.</p>\n\n<p><strong>Init Parameters:</strong> </p>\n\n<ul>\n<li>**kwargs (dict): Keyword  arguments to pass to the Generic_Webdriver class. These are the same as the Generic_Webdriver class.\nThese are:\n<ul>\n<li>driver (webdriver): A Selenium WebDriver object, can put in an active one or make a new one for a new URL.</li>\n<li>use_existing_driver (bool): Whether to use an existing driver in the namespace. If True, the driver parameter is ignored. Default is False.</li>\n<li>browser (str): The browser to use for scraping, either 'chrome' or 'firefox'.</li>\n<li>headless (bool): Whether to run the browser in headless mode (show no window).</li>\n</ul></li>\n</ul>\n", "bases": "tedata.base.Generic_Webdriver, tedata.base.SharedWebDriverState"}, {"fullname": "tedata.scraper.TE_Scraper.__init__", "modulename": "tedata.scraper", "qualname": "TE_Scraper.__init__", "kind": "function", "doc": "<p>Initialize shared state attributes, it is chart_type and date_span which we want to keep synced between the classes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tedata.scraper.TE_Scraper.BrowserType", "modulename": "tedata.scraper", "qualname": "TE_Scraper.BrowserType", "kind": "variable", "doc": "<p></p>\n", "default_value": "typing.Literal[&#x27;chrome&#x27;, &#x27;firefox&#x27;]"}, {"fullname": "tedata.scraper.TE_Scraper.load_page", "modulename": "tedata.scraper", "qualname": "TE_Scraper.load_page", "kind": "function", "doc": "<p>Load page and wait for it to be ready</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">url</span>, </span><span class=\"param\"><span class=\"n\">extra_wait_time</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.click_button", "modulename": "tedata.scraper", "qualname": "TE_Scraper.click_button", "kind": "function", "doc": "<p>Click button using webdriver and wait for response.\n<strong>Parameters:</strong></p>\n\n<ul>\n<li>selector (str): The CSS selector for the button to click.</li>\n<li>selector_type (By): The type of selector to use, By.CSS_SELECTOR by default.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">selector</span>, </span><span class=\"param\"><span class=\"n\">selector_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;css selector&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.find_max_button", "modulename": "tedata.scraper", "qualname": "TE_Scraper.find_max_button", "kind": "function", "doc": "<p>Find the button on the chart that selects the maximum date range and return the CSS selector for it.\nThe button is usually labelled 'MAX' and is used to select the maximum date range for the chart. The selector for the button is\nusually '#dateSpansDiv' but can be changed if the button is not found. The method will return the CSS selector for the button.\nThis will also create an atrribute 'date_spans' which is a dictionary containing the text of the date span buttons and their CSS selectors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#dateSpansDiv&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.click_max_button", "modulename": "tedata.scraper", "qualname": "TE_Scraper.click_max_button", "kind": "function", "doc": "<p>Click the button that selects the maximum date range on the chart. This is usually the 'MAX' button and is used to select the maximum date range for the chart.\nThe method will find the button and click it. It will also wait for the chart to update after clicking the button.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.determine_date_span", "modulename": "tedata.scraper", "qualname": "TE_Scraper.determine_date_span", "kind": "function", "doc": "<p>Determine the selected date span from the Trading Economics chart currently displayed in webdriver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">update_chart</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.update_chart", "modulename": "tedata.scraper", "qualname": "TE_Scraper.update_chart", "kind": "function", "doc": "<p>Update the chart attributes after loading a new page or clicking a button. This will check the page source and update the \nbeautiful soup objects such as chart_soup, from which most other methods derive their functionality. It will also update the full_chart attribute\nwhich is the full HTML of the chart element on the page. This method should be run after changing something on the webpage via driver such\nas clicking a button to change the date span or chart type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.set_date_span", "modulename": "tedata.scraper", "qualname": "TE_Scraper.set_date_span", "kind": "function", "doc": "<p>Set the date span on the Trading Economics chart. This is done by clicking the date span button on the chart. The date span is a button on the chart\nthat allows you to change the date range of the chart. This method will click the button for the date span specified in the date_span parameter.\nThe date_span parameter should be a string that matches one of the date span buttons on the chart. The method will also update the date_span attribute\nof the class to reflect the new date span.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">date_span</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.set_max_date_span_viaCalendar", "modulename": "tedata.scraper", "qualname": "TE_Scraper.set_max_date_span_viaCalendar", "kind": "function", "doc": "<p>Looks like Trading Economics have gone ahead and made the \"MAX\" button on charts a subscriber only feature. No problem, we can still set the max date range\nby using the calendar widget on the chart. This method will click the calendar button and then enter an arbitrary date far in the past as start date and the \ncurrent date as the end date.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.update_date_span", "modulename": "tedata.scraper", "qualname": "TE_Scraper.update_date_span", "kind": "function", "doc": "<p>Update the date span after clicking a button. This will check the page source and update the date span attribute.\nThis method can be used t check that the curret date span is correct after clicking a button to change it. \nIt will update the date_span attribute. It is not necessary after running set_date_span though as that method already updates the date span attribute.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>update_chart (bool): Whether to update the chart before determining the date span. Default is False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">update_chart</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.create_chart_types_dict", "modulename": "tedata.scraper", "qualname": "TE_Scraper.create_chart_types_dict", "kind": "function", "doc": "<p>Create a dictionary of chart types and their CSS selectors. This is used to select the chart type on the Trading Economics chart.\nThe dictionary is stored in the chart_types attribute of the class. The keys are the names of the chart types and the values are the CSS selectors\nfor the chart type buttons on the chart.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.select_chart_type", "modulename": "tedata.scraper", "qualname": "TE_Scraper.select_chart_type", "kind": "function", "doc": "<p>Select a chart type on the Trading Economics chart. This is done by clicking the chart type button and then selecting the specified chart type.\nThe chart type should be a string that matches one of the chart types in the chart_types dictionary. The method will click the chart type button\nand then select the specified chart type. It will also update the chart_type attribute of the class to reflect the new chart type.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>chart_type (str): The chart type to select on the chart. This must be one of the keys of the chart_types dictionary attribute of the class.\nList the options by printing self.chart_types.keys()</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">chart_type</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.set_chartType_js", "modulename": "tedata.scraper", "qualname": "TE_Scraper.set_chartType_js", "kind": "function", "doc": "<p>Set the chart type using javascript. This is a more robust method of setting the chart type than using the click_button method.\nThe click_button method can sometimes fail to click the chart type button. This method will set the chart type using javascript and will\nupdate the chart_type attribute of the class to reflect the new chart type.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>chart_type (Literal): The chart type to set. This should be one of the keys of the chart_types dictionary attribute of the class. The \noptions are 'Column', 'Spline', 'Areaspline', 'Stepline', 'Line', 'Area'.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">chart_type</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;Column&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Spline&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Areaspline&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Stepline&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Line&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Area&#39;</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_element", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_element", "kind": "function", "doc": "<p>Find element by selector. The data trace displayed on a Trading Economics chart is a PATH element in the SVG chart.\nThis is selected using the CSS selector \".highcharts-series path\" by default. The element is stored in the 'current_element' attribute.\nIt can be used to select other elements on the chart as well and assign that to current element attribute.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>selector (str): The CSS selector for the element to find.</li>\n<li>selector_type (By): The type of selector to use, By.CSS_SELECTOR by default.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li>element: The found element or None if not found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.highcharts-series path&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">selector_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;css selector&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.series_from_chart_soup", "modulename": "tedata.scraper", "qualname": "TE_Scraper.series_from_chart_soup", "kind": "function", "doc": "<p>Extract series data from element text. This extracts the plotted series from the svg chart by taking the PATH \nelement of the data tarace on the chart. Series values are pixel co-ordinates on the chart.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>invert_the_series (bool): Whether to invert the series values.</li>\n<li>return_series (bool): whether or not to return the series at end. Series is assigned to self.series always.</li>\n<li>set_max_datespan (bool): Whether to set the date span to MAX before extracting the series data. Default is False.</li>\n<li>local_run (bool): Whether the method is being run to get the full date_span series or just extacting part of the series\nto then aggregate together the full series. Default is False.</li>\n<li>use_chart_type (str): The chart type to use for the extraction of the series data. Default is \"Spline\". This is used to set the chart type before extracting the series data.\nCUATION: This method may fail with certain types of charts. It is best to use Spline unless you have a reason to use another type.</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li>series (pd.Series): The extracted series data that is the raw pixel co-ordinate values of the data trace on the svg chart.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.highcharts-graph&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">invert_the_series</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">set_max_datespan</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">local_run</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">use_chart_type</span><span class=\"p\">:</span> <span class=\"n\">Literal</span><span class=\"p\">[</span><span class=\"s1\">&#39;Line&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Spline&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Spline&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.custom_date_span", "modulename": "tedata.scraper", "qualname": "TE_Scraper.custom_date_span", "kind": "function", "doc": "<p>Set the date range on the active chart in the webdriver window. \nThis is done by entering the start and end dates into the date range input boxes</p>\n\n<p>Args:\n    start_date (str): Start date in format YYYY-MM-DD\n    end_date (str): End date in format YYYY-MM-DD</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;1900-01-01&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;2025-03-18&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.custom_date_span_js", "modulename": "tedata.scraper", "qualname": "TE_Scraper.custom_date_span_js", "kind": "function", "doc": "<p>Set the date range on the active chart in the webdriver window using JavaScript.\nThis is more reliable than using Selenium's send_keys and can avoid issues with focus.</p>\n\n<p>Args:\n    start_date (str): Start date in format YYYY-MM-DD\n    end_date (str): End date in format YYYY-MM-DD</p>\n\n<p>Returns:\n    bool: True if successful, False otherwise</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;1900-01-01&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;2025-03-18&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_datamax_min", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_datamax_min", "kind": "function", "doc": "<p>Get the max and min data values for the series using y-axis values... This is deprecated and not used in the current version of the code.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.scale_series", "modulename": "tedata.scraper", "qualname": "TE_Scraper.scale_series", "kind": "function", "doc": "<p>Scale the series using the first and last values from the series pulled from the tooltip box. Uses the y axis limits and the max and min of the y axis\nto determine the scaling factor to convert pixel co-ordinates to data values. The scaling factor is stored in the self.axlims_upp attribute.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">right_way_up</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_chart_dims", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_chart_dims", "kind": "function", "doc": "<p>Get dimensions of chart and plotting area</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_xlims_from_tooltips", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_xlims_from_tooltips", "kind": "function", "doc": "<p>Use the TooltipScraper class to get the start and end dates and some other points of the time series using the tooltip box displayed on the chart.\nTakes the latest num_points points from the chart and uses them to determine the frequency of the time series. The latest data is used\nin case the earlier data is of lower frequency which can sometimes occurr.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>force_rerun (bool): Whether to force a rerun of the method to get the start and end dates and frequency of the time series again. The method\nwill not run again by default if done a second time and start_end and frequency attributes are already set. If the first run resulted in erroneous\nassignation of these attributes, set this to True to rerun the method. However, something may need to be changed if it is not working...</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_max_datespan</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.make_x_index", "modulename": "tedata.scraper", "qualname": "TE_Scraper.make_x_index", "kind": "function", "doc": "<p>Make the DateTime Index for the series using the start and end dates scraped from the tooltips. \nThis uses Selenium and also scrapes the some of the latest datapoints from the tooltips on the chart in order to determine\nthe frequency of the time series. It will take a bit of time to run.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>force_rerun_xlims (bool): Whether to force a rerun of the method to get the start and end dates and frequency of the time series again. The method\nwill not run again by default if done a second time and start_end and frequency attributes are already set. </li>\n<li>force_rerun_freqdet (bool): Whether to force a rerun of the method to get the frequency of the time series again. The method\nwill not run again by default if done a second time and frequency attribute is already set.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">force_rerun_xlims</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">force_rerun_freqdet</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_earliest_points", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_earliest_points", "kind": "function", "doc": "<p>Get the earliest data points from the chart using the cursor, use this to check for series that have differing frequency\nat start and end.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">num_points</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;all&#39;</span>, </span><span class=\"param\"><span class=\"n\">num_years</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.full_series_fromTooltips", "modulename": "tedata.scraper", "qualname": "TE_Scraper.full_series_fromTooltips", "kind": "function", "doc": "<p>Scrape the full series from the dates and values displayed on the tooltips as the cursor is dragged across the chart. Uses javscript to handle the cursor \nmovement and tooltip retrieval and parsing. This is way faster than using a python loop. I suspect this may end up missing some points for series that \nhave many datapoints. However, it has worked for all series tested thus far. Assigns the resultant series to the series attribute.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">set_max_datespan</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.tooltip_multiScrape", "modulename": "tedata.scraper", "qualname": "TE_Scraper.tooltip_multiScrape", "kind": "function", "doc": "<p>Use the TooltipScraper object to scrape the full series from the chart. This is the most accurate method of scraping the full\nseries but s the slowest. The x_index attribute must be set before running this method. The method will use multiple runs\nof the javascript tooltip scraping script. It will be done in multiple runs to prevent points being missed. Number of runs\nwill depend upon the length of the x_index attribute.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_y_axis", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_y_axis", "kind": "function", "doc": "<p>Get y-axis values from chart to make a y-axis series with tick labels and positions (pixel positions).\nAlso gets the limits of both axis in pixel co-ordinates. A series containing the y-axis values and their pixel positions (as index) is assigned\nto the \"y_axis\" attribute. The \"axis_limits\" attribute is made too &amp; is  dictionary containing the pixel co-ordinates of the max and min for both x and y axis.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>update_chart (bool): Whether to update the chart before scraping the y-axis values. Default is False.</li>\n<li>set_global_y_axis (bool): Whether to set the y-axis series as a global attribute of the class. Default is False.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">update_chart</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">set_global_y_axis</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.init_tooltipScraper", "modulename": "tedata.scraper", "qualname": "TE_Scraper.init_tooltipScraper", "kind": "function", "doc": "<p>Initialise the TooltipScraper object for the class. This is used to scrape the tooltip box on the chart to get the start and end dates of the time series.\nThe tooltip scraper is a child object of the class and is used\nto scrape the tooltip box on the chart to get the start and end dates of the time series. The tooltip scraper is a child object of the class an shares some synced \nattributes with the parent class.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.dtIndex", "modulename": "tedata.scraper", "qualname": "TE_Scraper.dtIndex", "kind": "function", "doc": "<p>Create a date index for your series in self.series. Will first make an index to cover the full length of your series \nand then resample to month start freq to match the format on Trading Economics.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>start_date (str) YYYY-MM-DD: The start date of your series</li>\n<li>end_date (str) YYYY-MM-DD: The end date of your series</li>\n<li>ser_name (str): The name TO GIVE the series</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">ser_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Time-series&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.apply_x_index", "modulename": "tedata.scraper", "qualname": "TE_Scraper.apply_x_index", "kind": "function", "doc": "<p>Apply a datetime index to the series. This will set the datetime index as the index of the series and resample the series to the frequency\nof the datetime index. The series attribute of the class will be updated with the new series.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>x_index (pd.DatetimeIndex): The datetime index to apply to the series. If None, the x_index attribute of the class will be used.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">x_index</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_rounded_tempIndex</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">redo_series</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.extract_axis_limits", "modulename": "tedata.scraper", "qualname": "TE_Scraper.extract_axis_limits", "kind": "function", "doc": "<p>Extract axis limits from the chart in terms of pixel co-ordinates.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.plot_series", "modulename": "tedata.scraper", "qualname": "TE_Scraper.plot_series", "kind": "function", "doc": "<p>Plots the time series data using pandas with plotly as the backend. Plotly is set as the pandas backend in __init__.py for tedata.\nIf you want to use matplotlib or other plotting library don't use this method, plot the series attribute data directly. If using jupyter\nyou can set </p>\n\n<p><strong>Parameters</strong></p>\n\n<ul>\n<li>series (pd.Series): The series to plot. Default is None. If None, the series attribute of the class will be plotted.</li>\n<li>annotation_text (str): Text to display in the annotation box at the bottom of the chart. Default is None. If None, the default annotation text\nwill be created from the metadata.</li>\n<li>dpi (int): The resolution of the plot in dots per inch. Default is 300.</li>\n<li>ann_box_pos (tuple): The position of the annotation box on the chart. Default is (0, -0.23) which is bottom left.</li>\n</ul>\n\n<p><strong>Returns</strong> None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">series</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">annotation_text</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dpi</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"n\">ann_box_pos</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">show_fig</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">return_fig</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert_yaxis</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"o\">**</span><span class=\"n\">layout_updates</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.save_plot", "modulename": "tedata.scraper", "qualname": "TE_Scraper.save_plot", "kind": "function", "doc": "<p>Save the plot to a file. The plot must be created using the plot_series method. This method will save the plot as a PNG image file.</p>\n\n<p><strong>Parameters</strong></p>\n\n<ul>\n<li>filename (str): The name of the file to save the plot to. Default is 'plot.png'.</li>\n<li>save_path (str): The directory to save the plot to. Default is the current working directory.</li>\n<li>dpi (int): The resolution of the plot in dots per inch. Default is 300.</li>\n<li>format (str): The format to save the plot in. Default is 'png'. Other options are: \"html\", \"bmp\", \"jpeg\", \"jpg\".\nUse \"html\" to save as an interactive plotly plot.</li>\n</ul>\n\n<p>:Returns: None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;plot&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;/Users/jamesbishop/Documents/Python/Scraping/tedata&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dpi</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>,</span><span class=\"param\">\t<span class=\"nb\">format</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;png&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.scrape_metadata", "modulename": "tedata.scraper", "qualname": "TE_Scraper.scrape_metadata", "kind": "function", "doc": "<p>Scrape metadata from the page. This method scrapes metadata from the page and stores it in the 'metadata' attribute. The metadata\nincludes the title, indicator, country, length, frequency, source, , original source, id, start date, end date, min value, and max value of the series.\nIt also scrapes a description of the series if available and stores it in the 'description' attribute.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.export_data", "modulename": "tedata.scraper", "qualname": "TE_Scraper.export_data", "kind": "function", "doc": "<p>Export the series data to an excel .xlsx file. The series and metadata attributes must be set before running this method.\nOnly do it after scraping the series data. The metadata will be saved in a separate sheet in the same file.</p>\n\n<p><strong>Parameters</strong></p>\n\n<ul>\n<li>savePath (str): The directory to save the file to. Default is the current working directory.</li>\n<li>filename (str): The name of the file to save the data to. Default is the name of the series.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">savePath</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;/Users/jamesbishop/Documents/Python/Scraping/tedata&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.get_page_source", "modulename": "tedata.scraper", "qualname": "TE_Scraper.get_page_source", "kind": "function", "doc": "<p>Get current page source after interactions</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.scraper.TE_Scraper.close", "modulename": "tedata.scraper", "qualname": "TE_Scraper.close", "kind": "function", "doc": "<p>Clean up resources completely by closing the WebDriver and removing references</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.search", "modulename": "tedata.search", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.search.wd", "modulename": "tedata.search", "qualname": "wd", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/Users/jamesbishop/Documents/Python/Scraping/tedata/src/tedata&#x27;"}, {"fullname": "tedata.search.fdel", "modulename": "tedata.search", "qualname": "fdel", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/&#x27;"}, {"fullname": "tedata.search.logger", "modulename": "tedata.search", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.search (DEBUG)&gt;"}, {"fullname": "tedata.search.search_TE", "modulename": "tedata.search", "qualname": "search_TE", "kind": "class", "doc": "<p>Class for searching Trading Economics website and extracting search results.\nThis class is designed to search the Trading Economics website for a given term and extract the search results.\nIt can load the search page, enter a search term, and extract the URLs of the search results.</p>\n\n<p><strong>Init Parameters:</strong></p>\n\n<ul>\n<li>load_homepage (bool): If True, the class will load the Trading Economics home page when initialized.</li>\n<li>**kwargs: Additional keyword arguments to pass to the Generic_Webdriver class. These are the same as the Generic_Webdriver class.\nThese are:\n<ul>\n<li>browser (str): The browser to use for the webdriver. Options are 'chrome' or 'firefox'.</li>\n<li>headless (bool): If True, the browser will run in headless mode.</li>\n<li>use_existing_driver (bool): If True, the class will attempt to use an existing 'spare' webdriver instance if one is found.</li>\n<li>driver (webdriver): If provided, the class will use this webdriver instance instead of creating a new one.</li>\n</ul></li>\n</ul>\n", "bases": "tedata.base.Generic_Webdriver"}, {"fullname": "tedata.search.search_TE.__init__", "modulename": "tedata.search", "qualname": "search_TE.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">load_homepage</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tedata.search.search_TE.home_page", "modulename": "tedata.search", "qualname": "search_TE.home_page", "kind": "function", "doc": "<p>Load the Trading Economics home page.\n:Parameters:</p>\n\n<ul>\n<li>timeout (int): The maximum time to wait for the page to load, in seconds.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">30</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.search.search_TE.search_trading_economics", "modulename": "tedata.search", "qualname": "search_TE.search_trading_economics", "kind": "function", "doc": "<p>Search Trading Economics website for a given term and extract URLs of search results.\nThis method will search the Trading Economics website for a given term and extract the URLs of the search results.\nIt will enter the search term in the search box, submit the search, and extract the URLs of the search results.\nResults are assigned to the 'results' attribute as a list of URLs and as result_table attribute as a pandas df.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>search_term (str): The term to search for on the website.</li>\n<li>wait_time (int): The time to wait for the search results to load, in seconds (if you get an empty table \nof results, increase this time).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">search_term</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">wait_time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.search.search_TE.extract_search_results", "modulename": "tedata.search", "qualname": "search_TE.extract_search_results", "kind": "function", "doc": "<p>Extract URLs from search results page</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">html_content</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.search.search_TE.results_table", "modulename": "tedata.search", "qualname": "search_TE.results_table", "kind": "function", "doc": "<p>Create a DataFrame from the search results</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.search.search_TE.get_data", "modulename": "tedata.search", "qualname": "search_TE.get_data", "kind": "function", "doc": "<p>Scrape data for a given search result number.\nThis method will scrape data for a given search result number from the search results table.\nIt will extract the URL for the result and scrape the data from the chart at that URL.\nThe scraped data is assigned to the 'scraped_data' attribute as a TE_scraper object.\nThis will use the TE_Scraper class and methods to scrape the data from the Trading Economics website.</p>\n\n<p><strong>Parameters:</strong></p>\n\n<ul>\n<li>result_num (int): The index of the search result in your result table to scrape the data for.</li>\n<li>method (str): The method to use for scraping the data. Options are \"path\" (default) or \"tooltips\" or \"mixed\".</li>\n</ul>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li>scraped_data (TE_Scraper): The scraped data object. The data can be accessed from the 'series' attribute of the TE_SCraper object\nthat is returned. This object is also saved as the \"scraped_data\" attribute of the search_TE object.  The maximum length \nfor the indicator is always retrieved. Use slicing to reduce length if needed.</li>\n</ul>\n\n<p><em>* Example: *</em></p>\n\n<ul>\n<li>Run a search and display the \"result_table\" attribute of the search_TE object to see the search results:</li>\n</ul>\n\n<pre><code>search = search_TE()\nsearch.search_trading_economics(\"US ISM Services PMI\")\nsearch.result_table\n\n</code></pre>\n\n<ul>\n<li>Scrape the data for the 11th search result (counts from 0):</li>\n</ul>\n\n<pre><code>scraped = search.get_data(10)\nscraped.plot_series()  # This will plot an interactive plotly chart of the series.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">result_num</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;path&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">start_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">end_date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils", "modulename": "tedata.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "tedata.utils.logger", "modulename": "tedata.utils", "qualname": "logger", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;Logger tedata.utils (DEBUG)&gt;"}, {"fullname": "tedata.utils.wd", "modulename": "tedata.utils", "qualname": "wd", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/Users/jamesbishop/Documents/Python/Scraping/tedata/src/tedata&#x27;"}, {"fullname": "tedata.utils.fdel", "modulename": "tedata.utils", "qualname": "fdel", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;/&#x27;"}, {"fullname": "tedata.utils.n_years_later", "modulename": "tedata.utils", "qualname": "n_years_later", "kind": "function", "doc": "<p>Get date string n years later</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">date</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;1950-01-01&#39;</span>, </span><span class=\"param\"><span class=\"n\">n_years</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.check_browser_installed", "modulename": "tedata.utils", "qualname": "check_browser_installed", "kind": "function", "doc": "<p>Check if browsers are installed using Selenium's service checks</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.export_html", "modulename": "tedata.utils", "qualname": "export_html", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">html</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">save_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;/Users/jamesbishop/Documents/Python/Scraping/tedata/src/tedata/last_soup.html&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.split_numeric", "modulename": "tedata.utils", "qualname": "split_numeric", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">input_string</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.map_frequency", "modulename": "tedata.utils", "qualname": "map_frequency", "kind": "function", "doc": "<p>Map timedelta to frequency string</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">diff</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.get_date_frequency", "modulename": "tedata.utils", "qualname": "get_date_frequency", "kind": "function", "doc": "<p>Get the frequency of a date series, for weekly returns day-specific frequency (e.g. W-SUN)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">date_series</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.check_element_exists_bs4", "modulename": "tedata.utils", "qualname": "check_element_exists_bs4", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">soup</span>, </span><span class=\"param\"><span class=\"n\">selector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.convert_metric_prefix", "modulename": "tedata.utils", "qualname": "convert_metric_prefix", "kind": "function", "doc": "<p>Convert string with metric prefix to float, and return the remaining text.</p>\n\n<p>Examples:\n    '2.27K Thousand units' -> (2270.0, 'Thousand units')\n    '10 K units' -> (10000.0, 'units')\n    '1.3M' -> (1300000.0, '')\n    '5B Points' -> (5000000000.0, 'Points')</p>\n\n<p>Args:\n    value_str (str): String containing number and optional metric prefix</p>\n\n<p>Returns:\n    tuple: (converted_numeric_value: float, remaining_text: str)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.extract_and_convert_value", "modulename": "tedata.utils", "qualname": "extract_and_convert_value", "kind": "function", "doc": "<p>Extract numeric value with metric prefix from a string, convert it to a float,\nand return both the converted value and remaining non-numeric text. This is the complex version that will </p>\n\n<p>Complex cases handled:</p>\n\n<ul>\n<li>'1 M $' -> (1000000.0, '$')</li>\n<li>'246 k Thousand' -> (246000.0, '')</li>\n<li>'10 M million' -> (10000000.0, '')</li>\n<li>'2.3 k %' -> (2300.0, '%')</li>\n<li>'100 000.25 G' -> (100000250000000.0, '')</li>\n<li>'0.673 x10^-6' -> (0.000000673, '')</li>\n<li>'1.56 hundred Thousand' -> (156000.0, '')</li>\n</ul>\n\n<p>Args:\n    value_str (str): String containing number and optional metric prefix</p>\n\n<p>Returns:\n    tuple: (converted_numeric_value: float, remaining_text: str)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.ready_datestr", "modulename": "tedata.utils", "qualname": "ready_datestr", "kind": "function", "doc": "<p>Replace substrings in datestr using a dictionary to get the string ready\nfor parsing to datetime. Using QS frequency convention for quarters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">date_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.normalize_series", "modulename": "tedata.utils", "qualname": "normalize_series", "kind": "function", "doc": "<p>Normalize a pandas Series to a given range [new_min, new_max].</p>\n\n<p>Parameters:\nseries (pd.Series): The pandas Series to normalize.\nnew_min (float): The minimum value of the new range.\nnew_max (float): The maximum value of the new range.</p>\n\n<p>Returns:\npd.Series: The normalized pandas Series.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">series</span>, </span><span class=\"param\"><span class=\"n\">new_min</span>, </span><span class=\"param\"><span class=\"n\">new_max</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.invert_series", "modulename": "tedata.utils", "qualname": "invert_series", "kind": "function", "doc": "<p>Invert a pandas Series.</p>\n\n<p>Parameters:\nseries (pd.Series): The pandas Series to invert.</p>\n\n<p>Returns:\npd.Series: The inverted pandas Series.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">series</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">series</span><span class=\"o\">.</span><span class=\"n\">Series</span>, </span><span class=\"param\"><span class=\"n\">max_val</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.find_zero_crossing", "modulename": "tedata.utils", "qualname": "find_zero_crossing", "kind": "function", "doc": "<p>Find the x-intercept (value where series crosses zero) using linear interpolation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">series</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.round_to_month_start", "modulename": "tedata.utils", "qualname": "round_to_month_start", "kind": "function", "doc": "<p>Round dates to nearest month start.</p>\n\n<p>Args:\n    dates: DatetimeIndex of dates to round</p>\n\n<p>Returns:\n    DatetimeIndex: Dates rounded to nearest month start</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dates</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.round_to_freq", "modulename": "tedata.utils", "qualname": "round_to_freq", "kind": "function", "doc": "<p>Round dates to nearest frequency start.</p>\n\n<p>Args:\n    dates: DatetimeIndex to round\n    freq: Frequency string (e.g. 'MS', 'QS', 'AS', 'W-SUN')</p>\n\n<p>Returns:\n    DatetimeIndex: Dates rounded to nearest frequency start</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dates</span><span class=\"p\">:</span> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>,</span><span class=\"param\">\t<span class=\"n\">freq</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">pandas</span><span class=\"o\">.</span><span class=\"n\">core</span><span class=\"o\">.</span><span class=\"n\">indexes</span><span class=\"o\">.</span><span class=\"n\">datetimes</span><span class=\"o\">.</span><span class=\"n\">DatetimeIndex</span>:</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper", "modulename": "tedata.utils", "qualname": "TooltipScraper", "kind": "class", "doc": "<p>Extended version of TE_Scraper with additional functionality to scrape tooltip data from a chart element using Selenium.\nCan be initilized using a TE_Scraper object or a new URL. If using a new URL, a new webdriver will be created. If using an existing\nTE_Scraper object, the webdriver from that object will be used and all attributes will be copied over.\nThis can get x, y data from the tooltip box displayed by a site such as Trading Economics when the cursor\nis moved over a chart. It can move the cursor to specific points on the chart and extract tooltip text.\nIt extracts date and value data from the tooltip text.\nInitialize the scraper with a URL and chart coordinates</p>\n\n<p><strong>init Parameters:</strong></p>\n\n<ul>\n<li>parent_instance (scraper.TE_Scraper): A parent scraper object to copy attributes from. This is the most efficient way to initialize.</li>\n<li>**kwargs: Keyword arguments to pass to the parent class, these are TE_Scraper init key word arguments.\nGenerally you would not supply keyword arguments if you are using a parent_instance for initilization. The kwargs apply to creation\nof a new TE_Scraper object. See TE_scraper class for details on initialization of a fresh instance.</li>\n</ul>\n", "bases": "tedata.scraper.TE_Scraper"}, {"fullname": "tedata.utils.TooltipScraper.__init__", "modulename": "tedata.utils", "qualname": "TooltipScraper.__init__", "kind": "function", "doc": "<p>Initialize the TooltipScraper object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parent_instance</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">kwargs</span></span>)</span>"}, {"fullname": "tedata.utils.TooltipScraper.move_cursor", "modulename": "tedata.utils", "qualname": "TooltipScraper.move_cursor", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.move_pointer", "modulename": "tedata.utils", "qualname": "TooltipScraper.move_pointer", "kind": "function", "doc": "<p>Move cursor to a specific x-offset and y-offset from the chart element.\nUses Selenium ActionChains to move the cursor.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x_offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">y_offset</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">x_increment</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.first_last_dates_js", "modulename": "tedata.utils", "qualname": "TooltipScraper.first_last_dates_js", "kind": "function", "doc": "<p>Get first and last data points using JavaScript execution instead of ActionChains.\nMore reliable across different browser implementations and environments.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.first_last_dates", "modulename": "tedata.utils", "qualname": "TooltipScraper.first_last_dates", "kind": "function", "doc": "<p>Scrape first and last data points for the data series on the chart at TE using viewport coordinates.</p>\n\n<p><strong>Returns:</strong></p>\n\n<ul>\n<li>start_end: dict containing the start and end dates and values of the data series.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.latest_points_js", "modulename": "tedata.utils", "qualname": "TooltipScraper.latest_points_js", "kind": "function", "doc": "<p>Get data points by moving cursor across chart within viewport bounds using JavaScript.\nGets date and values from the tooltips that show up.</p>\n\n<p>Args:\n    num_points (int): Number of unique data points to collect before stopping. Use \"all\" to collect all points\n    increment (int, optional): Override the default increment calculation. Pixels to move per step\n    wait_time (int, optional): Override the default wait time between moves (milliseconds)\n    force_shortest_span (bool): Whether to force the chart to shortest timespan before scraping</p>\n\n<p>Returns:\n    list: List of data points as dictionaries with 'date' and 'value' keys</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">num_points</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">increment</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">wait_time</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">force_shortest_span</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.get_device_pixel_ratio", "modulename": "tedata.utils", "qualname": "TooltipScraper.get_device_pixel_ratio", "kind": "function", "doc": "<p>Get device pixel ratio to scale movements</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.extract_date_value_tooltip", "modulename": "tedata.utils", "qualname": "TooltipScraper.extract_date_value_tooltip", "kind": "function", "doc": "<p>Extract date and value from a single tooltip HTML</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.get_tooltip_text", "modulename": "tedata.utils", "qualname": "TooltipScraper.get_tooltip_text", "kind": "function", "doc": "<p>Get tooltip text from the chart element</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">tooltip_selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.highcharts-tooltip&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.show_position_marker", "modulename": "tedata.utils", "qualname": "TooltipScraper.show_position_marker", "kind": "function", "doc": "<p>Add visual marker at specified coordinates</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">duration_ms</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.mark_cursor_position", "modulename": "tedata.utils", "qualname": "TooltipScraper.mark_cursor_position", "kind": "function", "doc": "<p>Mark current cursor position with dot</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">duration_ms</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.move_cursor_on_chart", "modulename": "tedata.utils", "qualname": "TooltipScraper.move_cursor_on_chart", "kind": "function", "doc": "<p>Move cursor to chart origin (0,0) point</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">printout</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.bail_out", "modulename": "tedata.utils", "qualname": "TooltipScraper.bail_out", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.TooltipScraper.move_with_marker", "modulename": "tedata.utils", "qualname": "TooltipScraper.move_with_marker", "kind": "function", "doc": "<p>Move to position and show marker</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.get_chart_datespans", "modulename": "tedata.utils", "qualname": "get_chart_datespans", "kind": "function", "doc": "<p>Get the date spans from the Trading Economics chart currently displayed in the scraper object. The scraper object can be a TE_Scraperfrom the scraper module\nor TooltipScraper object from the utils module.</p>\n\n<p><em>* Parameters:</em>*</p>\n\n<ul>\n<li>scraper_object (TE_Scraper or TooltipScraper): The scraper object with the chart to scrape.</li>\n<li>selector (str): The CSS selector to find the date spans element. Default is '#dateSpansDiv'.</li>\n</ul>\n\n<p><em>* Returns:</em>*</p>\n\n<ul>\n<li>date_spans (dict): A dictionary with date span names as keys and CSS selectors for the button to select that span as values.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scraper_object</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">scraper</span><span class=\"o\">.</span><span class=\"n\">TE_Scraper</span><span class=\"p\">,</span> <span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">TooltipScraper</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#dateSpansDiv&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.click_button", "modulename": "tedata.utils", "qualname": "click_button", "kind": "function", "doc": "<p>Click button and wait for response...</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scraper_object</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">scraper</span><span class=\"o\">.</span><span class=\"n\">TE_Scraper</span><span class=\"p\">,</span> <span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">TooltipScraper</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">selector</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#dateSpansDiv&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">selector_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;css selector&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.show_position_marker", "modulename": "tedata.utils", "qualname": "show_position_marker", "kind": "function", "doc": "<p>Add visual marker at specified coordinates</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">scraper_object</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">scraper</span><span class=\"o\">.</span><span class=\"n\">TE_Scraper</span><span class=\"p\">,</span> <span class=\"n\">tedata</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">TooltipScraper</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">duration_ms</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "tedata.utils.plot_multi_series", "modulename": "tedata.utils", "qualname": "plot_multi_series", "kind": "function", "doc": "<p>Plots multiple series on a single chart using Plotly, with support for dual Y-axes.</p>\n\n<p><strong>Parameters</strong></p>\n\n<ul>\n<li>series_list (list): List of series to plot on left Y-axis. Can be a list of pandas Series objects\nor a list of dicts with format [{\"series\": series1, \"add_name\": \"string\"}, ...].</li>\n<li>right_series_list (list): List of series to plot on right Y-axis, same format as series_list.</li>\n<li>metadata (dict): Dictionary with metadata for left axis series (keys like \"country\", \"title\", \"units\").</li>\n<li>right_metadata (dict): Dictionary with metadata for right axis series, similar to metadata.</li>\n<li>annotation_text (str): Text to display in annotation box at the bottom of chart.</li>\n<li>colors (list): List of color names for left axis traces. Default cycles through standard colors.</li>\n<li>right_colors (list): List of color names for right axis traces. Default uses a different palette.</li>\n<li>ann_box_pos (tuple): Position of annotation box. Default is (0, -0.2) which is bottom left.</li>\n<li>show_fig (bool): Whether to display the figure immediately.</li>\n<li>return_fig (bool): Whether to return the plotly figure object.</li>\n</ul>\n\n<p><strong>Returns</strong> </p>\n\n<ul>\n<li>fig: Plotly figure object (if return_fig=True)</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">series_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">right_series_list</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">metadata</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">right_metadata</span><span class=\"p\">:</span> <span class=\"nb\">dict</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">annotation_text</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ann_box_pos</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>,</span><span class=\"param\">\t<span class=\"n\">colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">right_colors</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">show_fig</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">return_fig</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();